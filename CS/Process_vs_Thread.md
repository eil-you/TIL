# 프로세스(Process)와 스레드(Thread) 심화 정리

운영체제에서 실행되는 프로그램의 기본 단위인 프로세스와 그 안에서 실행되는 흐름인 스레드의 차이를 정리합니다.

---

## 1. 프로세스 vs 스레드 핵심 비교

### 1) 프로세스 (Process) : 하나의 집
- **정의**: 실행 중인 프로그램. 운영체제로부터 독립된 메모리 공간을 할당받습니다.
- **메모리 구조**: Code, Data, Stack, Heap 영역을 독립적으로 가집니다.
- **특징**: 프로세스끼리는 기본적으로 서로의 메모리에 접근할 수 없으며, 통신을 위해선 **IPC(Inter-Process Communication)**가 필요합니다. 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않습니다.

### 2) 스레드 (Thread) : 하나의 집안이 여러 명이 살고 있는 것
- **정의**: 프로세스 내에서 실행되는 여러 흐름의 단위.
- **메모리 구조**: 프로세스의 **Code, Data, Heap 영역을 공유**하며, **Stack 영역만 독립적**으로 가집니다.
- **특징**: 자원을 공유하므로 통신 비용이 적고 경제적입니다. 하지만 하나의 스레드가 오류로 종료되면 프로세스 전체가 영향을 받을 수 있습니다.

| 구분 | 프로세스 | 스레드 |
| :--- | :--- | :--- |
| **자원 할당** | 운영체제로부터 독립적 자원 할당 | 프로세스 내 자원을 공유 |
| **통신** | IPC 등을 사용 (비용 높음) | 공유 메모리를 통한 직접 통신 (비용 낮음) |
| **컨텍스트 스위칭** | 무거움 (오버헤드 큼) | 가벼움 (오버헤드 작음) |

---

## 2. 멀티 스레드 환경과 공유 자원 문제

스레드들이 Heap과 Data 영역을 공유하기 때문에 발생하는 문제입니다.

### 1) 임계 영역 (Critical Section)
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원의 코드 영역입니다.

### 2) 경쟁 상태 (Race Condition)
- 두 개 이상의 스레드가 공유 자원을 동시에 수정하려고 할 때, 실행 순서에 따라 결과값이 달라지는 문제입니다.
- **예시**: `count++` 연산
  1. 스레드1이 count(10)를 읽음
  2. 스레드2가 count(10)를 읽음
  3. 스레드1이 1을 더해 11을 저장
  4. 스레드2가 1을 더해 11을 저장 (**결과적으로 12가 되어야 하는데 11이 됨**)

### 3) 교착 상태 (Deadlock)
- 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태입니다.

---

## 3. 해결 방안: 다양한 동기화 및 설계 전략

공유 자원 문제를 해결하기 위해 단순히 '막는(Locking)' 것 외에도 여러 설계적/기술적 접근법이 있습니다.

### 1) 기술적 해결 기법 (Locking & Primitive)
- **Mutex (뮤텍스)**: 상호 배제(Mutual Exclusion). 오직 하나의 스레드만 락을 획득하여 자원을 사용합니다. (화장실 열쇠 1개)
- **Semaphore (세마포어)**: 카운팅 기법. 동시에 접근 가능한 스레드 개수를 제어합니다. (화장실 칸 n개)
- **Monitor (모니터)**: 뮤텍스와 상태 변수를 결합한 고수준 동기화 도구. Java의 `synchronized`가 내부적으로 모니터 메커니즘을 사용합니다.
- **Spinlock (스핀락)**: 락을 얻을 때까지 CPU를 소모하며 무한 루프를 도는 방식. 컨텍스트 스위칭 비용보다 대기 시간이 짧을 때 효율적입니다.

### 2) 비차단(Non-blocking) 및 성능 최적화 기법
- **CAS (Compare And Swap)**: 현재 값과 기대 값을 비교하여 일치할 때만 업데이트하는 원자적 연산 방식. (`AtomicInteger` 등)
- **Read-Write Lock**: 읽기 작업은 여러 스레드가 동시에 가능하게 하고, 쓰기 작업만 독점적으로 제한하여 성능을 높입니다.
- **Optimistic Locking (낙관적 락)**: 충돌이 드물다고 가정하고, 일단 수정 후 마지막에 버전 체크를 통해 충돌 여부를 확인하는 방식.

### 3) 설계적 해결 전략 (Architecture)
- **Immutability (불변 객체)**: 객체 생성 후 상태를 변경할 수 없게 만듭니다. 공유 자원이지만 수정이 불가능하므로 동기화 자체가 필요 없습니다. (`String`, `Integer` 등)
- **Thread Local**: 공유 자원을 사용하지 않고, 각 스레드마다 본인만의 독립된 저장소를 갖게 합니다. 다른 일꾼의 수첩을 절대 보지 않는 방식입니다.
- **Thread-safe Collections**: Java의 `ConcurrentHashMap`, `CopyOnWriteArrayList` 등 내부적으로 정교하게 동기화가 구현된 자료구조를 사용합니다.
- **Message Passing (Actor Model)**: 메모리를 공유하지 않고 데이터를 메시지로 주고받으며 통신하는 방식입니다. (예: Akka, Go의 Channel)

---

## 4. 해결 방안 선택 기준
- **수정 빈도가 낮고 조회가 많다면?** -> Read-Write Lock 또는 불변 객체 활용
- **충돌이 아주 드물게 발생한다면?** -> CAS 기반의 Non-blocking 라이브러리 활용
- **성능보다 데이터 일관성이 절대적으로 중요하다면?** -> `synchronized` 또는 명시적인 `Lock` 사용
- **스레드 간의 독립성이 보장된다면?** -> Thread Local 활용

