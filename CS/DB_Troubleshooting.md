# DB CPU 100% 장애 대응 가이드 (Slow Query & Lock)

DB CPU가 100%에 도달해 서비스가 마비된 상황은 긴박한 대응이 필요합니다. 이때 가장 먼저 확인해야 할 두 가지 핵심 요소와 그 진단/해결 방법을 정리합니다.

---

## 1. 첫 번째 체크: 느린 쿼리 (Slow Query) 진단 및 해결

CPU 부하의 가장 흔한 원인은 **인덱스를 타지 못해 수백만 건의 데이터를 풀 스캔(Full Scan)** 하는 쿼리입니다.

### 1) 찾는 방법 (MySQL 기준)
*   **실시간 확인**: `SHOW FULL PROCESSLIST;` 명령어로 현재 실행 중인 쿼리 목록을 확인합니다. `Time`이 길고 `State`가 `Sending data` 혹은 `Copying to tmp table`인 쿼리를 주목합니다.
*   **슬로우 쿼리 로그**: 설정된 시간(예: 1초) 이상 걸린 쿼리들이 저장된 `slow_query_log` 파일을 분석합니다.

### 2) 해결 방법 (Immediate & Long-term)
*   **응급 조치**: 장애를 유발하는 특정 쓰레드를 `KILL [process_id];` 명령으로 강제 종료하여 급한 불을 끕니다.
*   **근본 해결**:
    *   **EXPLAIN 실행**: 해당 쿼리 앞에 `EXPLAIN`을 붙여 실행 계획을 확인합니다. `type`이 `ALL`(Full Scan)인지, `rows`가 너무 많지는 않은지 체크합니다.
    *   **인덱스 추가**: `WHERE` 절이나 `JOIN` 조건에 사용된 컬럼에 적절한 인덱스를 생성합니다.
    *   **쿼리 튜닝**: 불필요한 `DISTINCT`, `GROUP BY`, 서브쿼리 등을 최적화합니다.

---

## 2. 두 번째 체크: 락 대기 (Lock Wait) 진단 및 해결

쿼리 자체는 빠르더라도, 특정 트랜잭션이 자원을 점유하고 놓아주지 않으면 뒤따르는 수많은 쿼리들이 대기 상태에 빠지며 CPU와 커넥션을 갉아먹습니다.

### 1) 찾는 방법
*   **트랜잭션 상태 확인**: `SELECT * FROM information_schema.innodb_trx;` 명령어를 통해 실행 중인 트랜잭션과 시작 시간을 확인합니다.
*   **블로킹 세션 추적**: 어떤 쿼리가 어떤 쿼리를 막고 있는지(Blocking/Waiting) 계층 구조로 보여주는 뷰를 조회합니다. (MySQL 8.0+ 에서는 `sys.innodb_lock_waits` 활용)

### 2) 해결 방법
*   **응급 조치**: 락을 잡고 있는 '가장 오래된 트랜잭션(Root Blocker)'을 찾아 `KILL` 합니다. 하나만 죽여도 뒤에 줄 서 있던 쿼리들이 한꺼번에 풀리며 정상화되는 경우가 많습니다.
*   **근본 해결**:
    *   **트랜잭션 범위 축소**: `@Transactional`이 붙은 메서드 안에 외부 API 호출(Network IO)이나 무거운 로직이 포함되어 있지 않은지 확인하고 분리합니다.
    *   **격리 수준 검토**: 불필요하게 높은 격리 수준을 사용 중이라면 `READ COMMITTED` 등으로 조절합니다.
    *   **인덱스 최적화**: 인덱스가 없으면 DB는 대상 행을 찾기 위해 전체 테이블에 락을 거는 경우가 있습니다. 정확한 인덱스는 락의 범위를 최소화(Row Lock)합니다.

---

## 🚀 장애 대응 요약 (Action Plan)

1.  **현상 파악**: `SHOW PROCESSLIST`로 현재 어떤 쿼리들이 쌓여 있는지 확인.
2.  **원인 식별**:
    - 특정 쿼리가 CPU를 다 먹고 있다면? -> **Slow Query** (인덱스 부재)
    - 쿼리들이 대거 `Waiting for lock` 상태라면? -> **Lock Wait** (트랜잭션 장기화)
3.  **조치**: 원인이 되는 프로세스 `KILL` -> 실행 계획 분석 -> 인덱스/코드 수정.
4.  **사후 방지**: 슬로우 쿼리 모니터링 알람 설정, DB 성능 프로파일링 시스템(APM) 도입.
