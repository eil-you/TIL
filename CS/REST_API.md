# RESTful API (Representational State Transfer)

REST는 웹의 기존 기술과 **HTTP 프로토콜을 그대로 활용**하기 위한 아키텍처 스타일입니다. 자원(Resource)을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미합니다.

## 1. REST의 핵심 요소
*   **자원 (Resource) - URI**: 모든 자원에는 고유한 ID가 있으며, 이는 서버에 존재합니다. (예: `/users/1`)
*   **행위 (Verb) - HTTP Method**: 자원에 대한 행위를 정의합니다. (`GET`, `POST`, `PUT`, `DELETE` 등)
*   **표현 (Representation)**: 자원을 어떻게 표현할 것인지 정의합니다. (대부분 `JSON` 또는 `XML`)

## 2. REST의 6가지 원칙 (Constraints)
RESTful 하다고 말하기 위해서는 다음의 원칙들을 준수해야 합니다.

1.  **Uniform Interface (일관된 인터페이스)**: URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행합니다.
2.  **Stateless (무상태성)**: 작업을 위한 상태 정보를 따로 저장하고 관리하지 않습니다. 서버는 들어오는 각각의 요청을 완전히 별개의 것으로 취급합니다.
3.  **Cacheable (캐시 가능성)**: HTTP의 기존 캐싱 기능을 적용할 수 있어 효율적인 서비스가 가능합니다.
4.  **Self-descriptiveness (자체 표현 구조)**: REST API 메시지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조를 가져야 합니다.
5.  **Client-Server 구조**: 서버(자원 제공)와 클라이언트(자원 요청)의 역할을 명확히 분리합니다.
6.  **Layered System (계층화 시스템)**: 클라이언트는 서버의 구성과 상관없이 중간 매체(프록시, 게이트웨이 등)를 거쳐 통신할 수 있습니다.

## 3. 리소스 설계를 위한 규칙 (Best Practices)
URI를 설계할 때 지켜야 할 주요 규칙들입니다.

*   **명사 사용**: `/getUsers` (X) → `/users` (O) 행위는 HTTP Method로 표현합니다.
*   **복수형 권장**: `/user/1` 보다는 `/users/1`이 컬렉션을 나타내기에 더 적합합니다.
*   **계층 관계 표현**: `/users/1/orders` (사용자 1의 주문 목록)
*   **소문자 사용**: URI에는 대문자 사용을 가급적 피합니다.
*   **하이픈(`-`) 사용**: 긴 단어는 하이픈으로 구분하며, 밑줄(`_`)은 사용하지 않습니다.

## 4. HTTP Method의 역할
| Method | 역할 | 특징 |
| :--- | :--- | :--- |
| **GET** | 리소스 조회 | 데이터 변경 없음 (Safe) |
| **POST** | 리소스 생성 | 새로운 데이터를 서버에 전달 |
| **PUT** | 리소스 전체 수정 | 리소스 전체를 교체함 |
| **PATCH** | 리소스 일부 수정 | 리소스의 특정 필드만 수정 |
| **DELETE** | 리소스 삭제 | 리소스를 제거함 |
| **OPTIONS** | 통신 옵션 확인 | 주로 CORS 설정 확인 시 사용 |
| **HEAD** | 헤더 정보 조회 | 바디를 제외하고 헤더 정보만 응답 |

## 5. REST의 장단점
### 장점
*   HTTP 프로토콜의 인프라를 그대로 사용하므로 별도의 인프라 구축이 필요 없습니다.
*   메시지가 스스로를 설명하므로(Self-descriptive) 이해하기 쉽습니다.
*   서버와 클라이언트의 역할을 명확하게 분리합니다.

### 단점
*   표준이 존재하지 않아 정의가 모호할 수 있습니다.
*   HTTP Method의 한계가 있습니다. (복잡한 로직 표현의 어려움)
*   구형 브라우저에서 일부 Method(`PUT`, `DELETE` 등)를 지원하지 않을 수 있습니다.

## 6. 예상 면접 질문 (Q&A)

**Q1. RESTful API란 무엇이며, 왜 사용하는가요?**
*   **A.** REST란 HTTP URI를 통해 자원을 명시하고, HTTP Method를 통해 해당 자원에 대한 CRUD 연산을 적용하는 아키텍처 스타일입니다. 별도의 인프라 없이 HTTP 프로토콜을 그대로 활용할 수 있고, 메시지가 자기 설명적(Self-descriptive)이어서 서버와 클라이언트 간의 협업이 쉬워지기 때문에 사용합니다.

**Q2. PUT과 PATCH의 차이점은 무엇인가요?**
*   **A.** **PUT**은 리소스의 **전체 수정**을 의미합니다. 요청 시 리소스의 전체 필드를 보내야 하며, 빠진 필드는 기본값이나 null로 덮어씌워질 수 있습니다. 반면 **PATCH**는 리소스의 **일부 수정**을 의미하며, 변경하고자 하는 필드만 전송합니다.

**Q3. REST API에서 멱등성(Idempotency)이란 무엇인가요?**
*   **A.** 연산을 여러 번 수행하더라도 결과가 달라지지 않는 성질을 의미합니다.
    *   **GET, PUT, DELETE**는 멱등성을 가집니다. (여러 번 호출해도 결과 상태가 동일)
    *   **POST**는 멱등성을 가지지 않습니다. (호출할 때마다 새로운 리소스가 생성될 수 있음)

**Q4. REST API 버즈워드인 "Stateless"에 대해 설명해 주세요.**
*   **A.** 서버가 클라이언트의 상태(세션, 로그인 정보 등)를 보관하지 않는 것을 의미합니다. 모든 요청은 필요한 정보를 모두 포함하고 있어야 하며, 이를 통해 서버는 단순해지고 확장성(Scalability)이 높아집니다.

**Q5. URI 설계 시 가장 중요하게 생각하는 원칙은 무엇인가요?**
*   **A.** 리소스를 명사로 표현하는 것과 행위를 HTTP Method로 분리하는 것입니다. 예를 들어 `/getUser/1`과 같이 동사를 포함하는 것보다 `/users/1`과 같이 리소스 자체에 집중하고 `GET` Method를 사용하는 것이 RESTful한 설계입니다.

**Q6. 대표적인 상태 코드(Status Code) 몇 가지만 설명해 주세요.**
*   **200 (OK)**: 요청 성공
*   **201 (Created)**: 리소스 생성 성공
*   **400 (Bad Request)**: 클라이언트의 요청 오류
*   **401 (Unauthorized)**: 인증되지 않은 사용자
*   **403 (Forbidden)**: 권한 부족
*   **404 (Not Found)**: 리소스를 찾을 수 없음
*   **500 (Internal Server Error)**: 서버 내부 오류

