# 데이터베이스 인덱스 (Database Index) 심화 정리

데이터베이스 인덱스는 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 책의 색인(Index)과 같은 역할을 하여, 데이터를 풀 스캔(Full Scan)하지 않고도 빠르게 원하는 정보를 찾을 수 있게 합니다.

---

## 1. 인덱스 자료구조

### 1) B-Tree (Balanced Tree) - 가장 일반적
대부분의 관계형 데이터베이스(MySQL, Oracle 등)가 기본으로 사용하는 자료구조입니다.
- **Balanced 상태**: 루트(Root)에서 리프(Leaf)까지의 거리가 일정하게 유지됩니다.
- **성능**: **O(log N)** 탐색 속도.
- **장점**: **범위 검색**(`>`, `<`), **정렬**(`ORDER BY`), **패턴 매칭**(`LIKE 'a%'`)이 모두 가능하여 범용성이 매우 높습니다.

### 2) Hash Index
Key-Value 형태로 데이터를 관리하는 자료구조입니다.
- **특징**: 컬럼의 값을 해시 함수로 변환하여 데이터를 찾습니다.
- **성능**: 단일 값 검색 시 **O(1)**로 매우 빠릅니다.
- **한계 (일반적으로 사용되지 않는 이유)**:
    - **범위 검색 불가**: 해시 함수는 조금만 값이 달라도 완전히 다른 해시값을 생성하므로 정렬이 불가능합니다. 따라서 `>`, `<` 같은 범위 검색 시 성능 혜택을 전혀 못 받습니다.
    - **부분 일치 검색 불가**: `LIKE 'abc%'` 처럼 앞부분만 맞는 데이터를 찾는 검색이 불가능합니다.
    - **복합 인덱스 활용 불가**: 모든 컬럼을 다 합쳐서 해싱하므로 일부 컬럼만 조건에 넣을 경우 검색이 안 됩니다.


---

## 2. 클러스터형 vs 비클러스터형 인덱스

### 1) 클러스터형 인덱스 (Clustered Index)
- **물리적 정렬**: 실제 데이터 테이블의 행들이 인덱스 순서에 따라 **물리적으로 정렬**되어 저장됩니다.
- **구조**: B-Tree의 리프 노드가 곧 **데이터 페이지**입니다. 즉, 인덱스를 찾으면 그 자리에 실제 데이터가 다 들어있습니다.
- **특징**:
    - 테이블당 **딱 1개**만 생성 가능합니다. (보통 기본키(PK)가 이 역할을 수행)
    - 데이터 자체가 정렬되어 있으므로 **범위 검색(Range Scan)**에서 압도적인 성능을 보입니다.
    - 데이터 삽입/수정 시 물리적 순서를 유지해야 하므로 **페이지 분할(Page Split)** 현상이 발생하여 오버헤드가 클 수 있습니다.

### 2) 비클러스터형 인덱스 (Non-Clustered Index, 보조 인덱스)
- **논리적 정렬**: 데이터 자체는 정렬되지 않고, 별도의 장소에 인덱스 페이지를 만들어 관리합니다.
- **구조**: 리프 노드에 실제 데이터 대신 **데이터가 위치한 주소값(RID)** 또는 **클러스터형 인덱스의 키(PK 값)**가 들어있습니다.
- **특징**:
    - 테이블당 **여러 개**를 만들 수 있습니다.
    - 원하는 데이터를 찾기 위해 `인덱스 페이지 탐색 -> 실제 데이터 페이지 탐색`의 2단계 과정을 거칩니다. 이를 **RID Lookup** 또는 **Key Lookup**이라고 합니다.

### 3) 성능 및 동작 차이점 요약
| 항목 | 클러스터형 (사전) | 비클러스터형 (찾아보기) |
| :--- | :--- | :--- |
| **물리적 구조** | 데이터 페이지가 곧 인덱스 | 별도의 인덱스 페이지 존재 |
| **정렬 상태** | 물리적으로 정렬됨 | 논리적으로만 정렬됨 |
| **데이터 접근** | 인덱스 리프가 곧 데이터 | 인덱스 리프에서 주소를 보고 다시 찾아감 |
| **조회(SELECT)** | 매우 빠름 | 빠르지만 클러스터형보다는 추가 비용 발생 |
| **변경(CUD)** | 페이지 재정렬로 인해 느림 | 페이지 추가/수정 비용 발생 |

> **꿀팁**: MySQL의 InnoDB 엔진에서는 비클러스터형 인덱스가 실제 데이터 주소 대신 **PK(Primary Key) 값**을 들고 있습니다. 따라서 비클러스터형 인덱스로 검색하면 다시 PK 인덱스를 타고 내려가는 과정이 추가됩니다. 이를 방지하기 위해 인덱스에 필요한 컬럼을 다 포함시키는 **커버링 인덱스(Covering Index)** 기법을 사용하기도 합니다.


---

## 3. 복합 인덱스 (Composite Index)
두 개 이상의 컬럼을 합쳐서 하나의 인덱스로 만드는 것입니다. 실무에서는 단일 컬럼 인덱스보다 복합 인덱스를 잘 구성하는 것이 성능 최적화의 핵심입니다.

### 1) 컬럼 순서의 중요성 (Left-most Prefix)
복합 인덱스는 첫 번째 컬럼을 기준으로 먼저 정렬되고, 그 안에서 두 번째 컬럼으로 정렬되는 방식입니다.
- **예시**: `(성별, 이름)` 순서로 인덱스를 만들었다면?
    - `WHERE 성별 = 'M' AND 이름 = '홍길동'` : **인덱스 사용 가능**
    - `WHERE 성별 = 'M'` : **인덱스 사용 가능**
    - `WHERE 이름 = '홍길동'` : **인덱스 사용 불가** (첫 번째 컬럼인 '성별' 조건이 없으므로)

### 2) 인덱스 컬럼 선정 및 순서 전략
1. **WHERE 절에 자주 사용되는 컬럼**을 우선합니다.
2. **동등 조건(`=`)**으로 쓰이는 컬럼을 앞쪽에, **범위 조건(`<`, `>`, `BETWEEN`, `LIKE`)**으로 쓰이는 컬럼을 뒤쪽에 배치합니다.
   - 범위 조건이 앞쪽에 오면 그 뒤쪽 컬럼들은 인덱스 혜택을 제대로 받지 못합니다.
3. **카디널리티(Cardinality)**가 높은 컬럼(중복도가 낮은 컬럼)을 앞에 두는 것이 보통 유리합니다.
   - 하지만 '동등 조건' 여부가 카디널리티보다 더 중요하게 작용할 때가 많습니다.

### 3) 인덱스 스킵 스캔 (Index Skip Scan)
최신 DB(MySQL 8.0+, Oracle 등)는 첫 번째 컬럼이 조건절에 없더라도 인덱스를 활용하는 '스킵 스캔' 기능을 제공하기도 하지만, 직접 매칭되는 것보다는 느립니다.


---

## 4. 인덱스 사용 시 주의사항 (Scan vs Seek)

- **Index Seek**: 인덱스를 타고 필요한 부분만 골라내는 효율적인 방식.
- **Index Scan**: 인덱스의 전체 페이지를 다 읽는 방식. 데이터 양에 따라 Full Table Scan만큼 느려질 수 있습니다.

### 인덱스가 작동하지 않는 경우 (Antipatterns)
1. **함수나 연산 사용**: `WHERE ABS(column) = 1` 등 컬럼을 가공하면 인덱스를 타지 못합니다.
2. **LIKE 전방 일치 미사용**: `LIKE '%word'` (뒤쪽만 아는 경우)는 인덱스를 활용할 수 없습니다. (`LIKE 'word%'`는 가능)
3. **OR 조건**: `OR`로 연결된 컬럼 중 하나만 인덱스가 있다면 성능이 저하될 수 있습니다.

---

## 5. 인덱스 설계 가이드라인
1. **WHERE 절**에 자주 등장하는 컬럼.
2. **JOIN** 조건으로 자주 사용되는 컬럼.
3. **카디널리티(데이터 식별도)**가 높은 컬럼.
4. **INSERT, UPDATE, DELETE**가 너무 빈번하지 않은 테이블. (CUD 작업 시 인덱스 재정렬 비용 발생)
-
+