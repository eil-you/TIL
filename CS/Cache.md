# 캐시 (Cache) 이해하기

**캐시(Cache)**는 데이터나 값을 미리 복사해 놓는 **임시 저장소**를 말합니다. 원래 데이터를 가져오는 시간이 오래 걸리거나 계산이 복잡할 때, 그 결과를 빠른 곳에 저장해두고 재사용하여 시스템의 성능을 높이는 것이 목적입니다.

---

## 1. 쉬운 비유: 도서관과 책상
- **도서관 (원래 저장소/DB)**: 책이 수만 권 있지만, 내가 원하는 책을 찾아서 빌려오려면 시간이 오래 걸립니다.
- **내 책상 (캐시/Cache)**: 도서관에서 빌려온 책을 책상 위에 올려둡니다. 다음에 그 책을 다시 보고 싶을 때 도서관까지 갈 필요 없이 책상에서 바로 꺼내 볼 수 있습니다. 

---

## 2. 왜 캐시를 사용하나요?

1.  **속도 향상**: 느린 저장소(HDD/SSD)나 네트워크(API 호출) 대신 빠른 저장소(RAM)에 데이터를 두어 응답 시간을 단축합니다.
2.  **부하 감소**: 매번 데이터베이스(DB)를 조회하거나 복잡한 계산을 반복하지 않아도 되므로, 서버의 자원을 아낄 수 있습니다.
3.  **비용 절감**: 클라우드 환경에서 API 호출 횟수나 DB 쿼리 비용을 줄일 수 있습니다.

---

## 3. 우리 주변의 캐시 사례

- **웹 브라우저 캐시**: 이전에 방문한 사이트의 이미지, CSS 파일을 내 컴퓨터에 저장해두어서 다음에 들어갈 때 더 빨리 로딩되게 합니다.
- **CPU 캐시 (L1, L2, L3)**: 아주 빠른 연산 처리를 위해 CPU 내부에 아주 작은 메모리를 두어 메인 메모리(RAM)와의 속도 차이를 메꿉니다.
- **데이터베이스 캐시**: 자주 조회되는 쿼리 결과를 메모리에 저장해두어 DB의 부담을 줄입니다. (예: Redis, Memcached)

---

---

## 4. Redis(Remote Dictionary Server)란?

현대 서비스에서 가장 많이 쓰이는 캐시 서버이자 인메모리 데이터 구조 저장소입니다.

### 왜 Redis를 쓰는가?
1. **인메모리(In-Memory) 성능**: 데이터를 디스크가 아닌 RAM에 저장하므로 읽기/쓰기 속도가 압도적으로 빠릅니다.
2. **다양한 자료구조**: 단순히 문자열뿐만 아니라 List, Set, Hash 등을 지원하여 활용도가 높습니다.
3. **영속성 지원**: 메모리에 저장하지만 특정 시점의 데이터를 디스크에 저장(RDB/AOF)할 수 있어 데이터 유실을 방지할 수 있습니다.
### 4) 싱글 스레드 기법 (Single-Threaded Architecture)
Redis가 멀티 스레드가 아닌 **싱글 스레드**로 동작함에도 압도적으로 빠른 이유는 다음과 같습니다.

1. **컨텍스트 스위칭(Context Switching) 오버헤드 제거**:
   - 멀티 스레드 환경에서는 CPU가 여러 스레드를 번갈아 가며 처리하기 위해 현재 상태를 저장하고 복원하는 '컨텍스트 스위칭' 비용이 발생합니다. Redis는 한 번에 하나의 명령어만 순차적으로 처리하므로 이 비용이 전혀 없습니다.
2. **잠금 성능 저하(Lock Contention) 없음**:
   - 공유 자원에 여러 스레드가 동시에 접근하면 데이터 보호를 위해 뮤텍스(Mutex)나 세마포어(Semaphore) 같은 '잠금(Lock)'이 필요합니다. 락을 걸고 푸는 과정은 성능을 크게 떨어뜨리는데, Redis는 싱글 스레드라 락 자체가 필요 없습니다.
3. **원자성(Atomicity) 보장**:
   - 한 번에 하나의 명령어만 실행되므로, 중간에 다른 명령어가 끼어들 수 없습니다. 따라서 복잡한 동기화 처리를 고민하지 않아도 태생적으로 **경쟁 상태(Race Condition)**로부터 자유롭습니다.
4. **I/O 멀티플렉싱(I/O Multiplexing)**:
   - 실제 명령어 처리는 싱글 스레드지만, 네트워크 연결은 `epoll` 같은 기술을 통해 수만 개의 연결을 동시에 효율적으로 관리합니다. 즉, '기다리는 시간'을 최소화하여 싱글 스레드의 한계를 극복합니다.

> **💡 주의**: 명령어 하나가 너무 오래 걸리면(예: 수백만 개의 키를 한 번에 조회) 뒤에 대기 중인 모든 요청이 멈추게 됩니다. 이를 **'Stop-the-world'** 현상이라 하며, Redis 사용 시 가장 주의해야 할 점입니다.


---

## 5. 데이터 정합성(Data Consistency) 문제

캐시를 사용할 때 가장 주의해야 할 점은 **"원본 데이터(DB)와 캐시 데이터가 서로 다를 수 있다"**는 것입니다.

### 1) 문제가 생기는 상황
- DB에서 데이터를 수정했는데, 캐시에는 여전히 옛날 데이터가 남아있는 경우.
- 클라이언트는 캐시에서 데이터를 읽어가므로, 수정된 사실을 모르고 잘못된 정보를 보게 됩니다.

### 2) 해결 전략 (Cache Invalidation)
데이터 정합성을 유지하기 위해 캐시를 적절히 비워주는 전략이 필요합니다.

1. **TTL (Time To Live)**: 캐시 데이터가 일정 시간이 지나면 자동으로 사라지게 설정합니다. (가장 기본적임)
2. **Write-Through**: DB를 업데이트할 때 캐시도 같이 실시간으로 업데이트합니다. (데이터가 항상 최신이지만 속도가 조금 느려질 수 있음)
3. **Write-Around**: DB만 업데이트하고 캐시는 건드리지 않습니다. 데이터가 바뀐 후 첫 조회 시 Cache Miss가 나면서 최신 데이터가 캐싱됩니다.
4. **Cache Aside (Look-Aside)**: 조회할 때 캐시를 먼저 확인하고, 없으면 DB에서 가져와 캐시에 저장합니다. (가장 널리 쓰임)

---

## 6. 결론: 캐시 관리의 핵심
> "컴퓨터 과학에는 두 가지 난제가 있다: 하나는 캐시 무효화(Invalidation)이고, 다른 하나는 이름 짓기이다." - 필 칼튼

캐시는 성능을 획기적으로 올리지만, **데이터가 꼬이지 않게 관리(정합성 유지)하는 설계**가 무엇보다 중요합니다.

