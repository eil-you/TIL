# 트랜잭션 격리 수준과 동시성: '초과 예약' 문제 해결

## Q1. 트랜잭션을 썼는데도 왜 '초과 예약'이 발생할까?

동시에 100명이 방 1개를 예약할 때, 단순하게 `@Transactional`만 사용하는 것으로는 동시성 문제를 완벽히 막을 수 없습니다.

### 1) Race Condition (경쟁 상태) 발생
가장 큰 이유는 **"조회 후 수정(Read-Then-Write)"** 과정 사이의 간극 때문입니다.
1.  **A 트랜잭션**: "방 남았나? (SELECT)" -> "1개 남았네!"
2.  **B 트랜잭션**: "방 남았나? (SELECT)" -> "1개 남았네!" (A가 아직 커밋 전이라 1개로 보임)
3.  **A 트랜잭션**: "예약 완료! (UPDATE count = count - 1)"
4.  **B 트랜잭션**: "예약 완료! (UPDATE count = count - 1)"
*   **결과**: 방은 1개였는데 예약은 2명이 성공하는 **초과 예약(Overbooking)** 발생.

### 2) 격리 수준(Isolation Level)의 한계
*   **READ COMMITTED (대부분의 운영 DB 기본값)**: 다른 트랜잭션이 커밋한 데이터만 읽을 수 있지만, 내 트랜잭션이 끝나기 전에 다른 놈이 데이터를 바꿔버릴 수 있습니다. (Non-Repeatable Read 발생)
*   **REPEATABLE READ (MySQL InnoDB 기본값)**: 내 트랜잭션 내에서는 항상 같은 값을 보장하지만, **Phantom Read**(새로운 행이 생기거나 사라짐) 현상은 완벽히 막지 못할 수 있습니다. (단, InnoDB는 Next-Key Lock으로 상당 부분 방어함)

---

## Q2. 데이터 정합성을 지키기 위한 선택지

### 방법 1: 비관적 락 (Pessimistic Lock) - "조회할 때부터 문 잠그기"
*   **원리**: `SELECT ... FOR UPDATE` 구문을 사용하여 데이터를 읽는 순간 다른 트랜잭션이 접근하지 못하게 락을 겁니다.
*   **장점**: 데이터 정합성이 확실합니다.
*   **단점**: 100명이 줄을 서서 기다려야 하므로 성능(Throughput)이 매우 떨어지고, 데드락(Deadlock) 위험이 있습니다.

### 방법 2: 낙관적 락 (Optimistic Lock) - "수정할 때 버전 체크하기"
*   **원리**: 데이터에 `Version` 컬럼을 두고, 수정할 때 "내가 읽은 버전과 같은가?"를 확인합니다. `UPDATE ... WHERE id=? AND version=1`.
*   **장점**: 별도의 락을 걸지 않아 속도가 빠릅니다.
*   **단점**: 충돌이 발생하면 사용자에게 에러를 뱉거나 애플리케이션 레벨에서 **재시도(Retry)** 로직을 구현해야 합니다. 100명이 동시에 달려들면 1명만 성공하고 99명은 실패(충돌)하게 됩니다.

### 방법 3: 서비스 기획적 타협 (Alternative Strategies)
실제 서비스(예: 여기어때, 야놀자)에서는 단순히 격리 수준만 높이지 않습니다.

1.  **원자적 업데이트 (Atomic Update)**:
    `UPDATE room SET count = count - 1 WHERE id = ? AND count > 0;`
    쿼리 자체에 조건을 걸어 DB 엔진의 단일 행 락(Row Lock)을 활용합니다.
2.  **분산 락 (Distributed Lock)**:
    Redis의 Redlock 등을 사용하여 여러 서버 분산 환경에서도 단 하나의 요청만 처리하도록 보장합니다. (선착순 이벤트에 적합)
3.  **대기열 시스템**:
    요청을 바로 DB에 꽂지 않고 Kafka나 Redis Queue에 쌓아 순차적으로 처리합니다.

---

## 🚀 최종 선택 전략

1.  **일반적인 숙소 예약**: **비관적 락(`Pessimistic Write`)** 또는 **원자적 업데이트**를 선호합니다. 숙소 데이터는 데이터 양보다 정확도가 훨씬 중요하며, 100명이 0.1초 만에 동시에 예약하는 케이스는 드물기 때문입니다.
2.  **초특가 선착순 이벤트**: **Redis 기반 분산 락** 또는 **대기열** 방식을 선택합니다. DB에 100개의 커넥션을 맺고 기다리게 하는 것보다, 앞단에서 빠르게 거르는 것이 전체 시스템 가용성에 유리합니다.
3.  **데이터 정합성 vs 사용자 경험**:
    - **정합성 우선**: 예약은 절대로 초과되면 안 됩니다. (금전적/신뢰 문제)
    - **타협점**: 만약 기술적 오류로 초과 예약 시, 사용자에게 즉시 보상(포인트 등)과 알림을 주는 '사후 방어 기제'를 기획적으로 마련해 둡니다.

---

## 요약
- **초과 예약 이유**: 로직의 "조회-수정" 사이의 경쟁 상태 때문.
- **해결책**:
    - 확실한 방어: **비관적 락** (`SELECT FOR UPDATE`)
    - 높은 처리량: **분산 락 (Redis)** 또는 **원자적 업데이트**
    - 격리 수준을 `SERIALIZABLE`로 높이는 것은 성능 최악이므로 실무에서 거의 사용 안 함.
