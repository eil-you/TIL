# [PCCP 기출문제] 2번 - 공원

## 1. 유형: 구현(Implementation), 완전 탐색(Brute Force)
> 2차원 격자에서 특정 조건(빈 자리)을 만족하는 **최대 정사각형**을 찾는 전형적인 문제입니다. 
> 제약 조건에 따라 **브루트 포스(완전 탐색)**로직으로 풀거나, **DP(다이나믹 프로그래밍)**를 활용해 최적화할 수 있습니다.

## 2. 문제 설명
지민이는 다양한 크기의 정사각형 모양 돗자리를 가지고 공원에 소풍을 나왔습니다. 
공원에는 이미 돗자리를 깔고 여가를 즐기는 사람들이 많아 지민이가 깔 수 있는 가장 큰 돗자리가 어떤 건지 확인하려 합니다. 
예를 들어 지민이가 가지고 있는 돗자리의 한 변 길이가 5, 3, 2 세 종류이고, 
사람들이 다음과 같이 앉아 있다면 지민이가 깔 수 있는 가장 큰 돗자리는 3x3 크기입니다.

지민이가 가진 돗자리들의 한 변의 길이들이 담긴 정수 리스트 mats, 
현재 공원의 자리 배치도를 의미하는 2차원 문자열 리스트 park가 주어질 때 지민이가 깔 수 있는 
가장 큰 돗자리의 한 변 길이를 return 하도록 solution 함수를 완성해 주세요.
아무런 돗자리도 깔 수 없는 경우 -1을 return합니다.

### 매개변수
- `mats`: 지민이가 가지고 있는 돗자리의 한 변의 길이들이 담긴 정수 리스트
- `park`: 현재 공원의 자리 배치도를 의미하는 2차원 문자열 리스트

### 반환값
- 지민이가 깔 수 있는 가장 큰 돗자리의 한 변 길이를 return 합니다.
- 아무런 돗자리도 깔 수 없는 경우 -1을 return 합니다.

### 제약 조건
- 1 <= mats.length <= 10
- 1 <= park.length <= 10
- 1 <= park[i].length <= 10
- park[i][j]는 'O' 또는 'X'로 이루어져 있습니다.
- mats[i]는 1 이상 10 이하의 정수입니다.


## 풀이 전략
- 공원에서 최대의 정사각형을 찾는 문제
1. mats을 오름차순으로 정렬
2. 전체 순회 해서 돗자리 깔 수 있는 위치 찾기(i, j)
3. 해당 위치에 돗자리를 깔수 있는지 확인하는 방법 필요


## 3. 직접 코드 구현(java)
```java
    class Solution {
        public int solution(int[] mats, String[][] park) {
            int answer = -1;
            
            // 1. mats 오름차순 정렬
            Arrays.sort(mats);

            // 2. size 큰 수 부터 확인
            for(int i = mats.length-1 ; i>=0 ; i--){
                int size = mats[i];
                if(canPlace(size, park)){
                    return size;
                }

            }

            return answer;
        }

        private boolean canPlace(int size, String[][] park){
            int rows = park.length;
            int cols = park[0].length;
            
            for(int i = 0 ; i < rows ; i++){
                for(int j = 0 ; j < cols ; j++){
                    if(isAllEmpty(i, j, size, park)) return true;
                }
            }   
            return false;
        }

        private boolean isAllEmpty(int i, int j, int size, String[][] park){
            for(int x = i ; x < i+size ; x++){
                for(int y = j ; y < j+size ; y++){
                    if(!park[x][y].equals("-1")) return false;
                }
            }
            return true;
    }
}
```

## 4. DP 방식 풀이 (최적화)

2차원 격자에서 가장 큰 정사각형을 찾는 문제는 **DP(다이나믹 프로그래밍)**를 사용하면 $O(N \times M)$의 시간 복잡도로 효율적으로 해결할 수 있습니다.

### 핵심 아이디어
- `dp[i][j]` : `(i, j)` 지점을 우측 하단 꼭짓점으로 하는 최대 정사각형의 한 변의 길이
- **점화식**: `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1` (현재 칸이 빈칸일 때)
- 주변 세 칸(위, 왼쪽, 왼쪽 대각선 위)이 모두 특정 크기 이상의 정사각형을 형성해야만 현재 칸을 포함해 더 큰 정사각형을 만들 수 원리를 이용합니다.

```java
import java.util.*;

class Solution {
    public int solution(int[] mats, String[][] park) {
        int rows = park.length;
        int cols = park[0].length;
        int[][] dp = new int[rows][cols];
        int maxSide = 0;

        // 1. DP 테이블 채우기
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 빈자리("-1")일 경우에만 계산
                if (park[i][j].equals("-1")) {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }

        // 2. 가진 돗자리 중 가능한 가장 큰 크기 찾기 (내림차순 확인)
        Arrays.sort(mats);
        for (int i = mats.length - 1; i >= 0; i--) {
            if (mats[i] <= maxSide) {
                return mats[i];
            }
        }

        return -1;
    }
}
```