# 비밀지도

## 1. 문제 설명
네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
"지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.


네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.


### 매개 변수
- int n : 지도의 한 변의 길이
- int[] arr1 : 지도 1
- int[] arr2 : 지도 2

### 반환값
- String[] : 비밀지도

### 제약 조건
- arr1과 arr2의 길이는 1 이상 16 이하입니다.
- arr1과 arr2의 각 원소는 0 이상 2^15 - 1 이하입니다.


## 2. 문제 풀이
1. Integer.toBinaryString()을 사용하여 이진수로 변환
2. 비트연산자(|)를 사용하여 두 지도의 숫자를 OR 연산하여 2진수로 변환
3. String.format("%" + n + "s", binary)를 사용하여 자릿수 맞추기
4. replace("1", "#").replace("0", " ")를 사용하여 1은 #으로, 0은 공백으로 변환

*** int[][]를 사용하지 않는 이유 ***
- 알고리즘에서 메모리를 아끼는 것도 실력
- 비트 연산을 쓰면 굳이 2차원 배열을 만들어 숫자를 하나하나쪼개서 담을 필요없이, 숫자 하나를 한 줄의 정보로 바로 처리할 수 있음


## 3. 다른 풀이(비트연산|)
```java
class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        String[] answer = new String[n];
        
        for(int i= 0; i< n ; i++){
            // 1. 두 지도의 숫자를 비트 OR 연산으로 함칩
            // 예: 9(01001) | 30(11110) = 31(11111)
            // Integer.toBinaryString()은 2진수로 변환
            String binary = Integer.toBinaryString(arr1[i] | arr2[i]);
            
            // 2. 자릴수 맞추기(앞에 0 채우기)
            // n =5 인데 binary가 "1001"이면 " 1001"로 만든 뒤 0으로 바꿈
            binary = String.format("%" + n + "s", binary);

            // 3. 1.은 '#', 0은 ' '로 치환
            answer[i] = binary.replace("1", "#").replace("0", " ");
        }
        
        return answer;
    }
}
```


1. int[][]map을 생성
2. arr1과 arr2를 이진수로 변환하여 map에 저장
3. map을 순회하며 1이면 #으로, 0이면 공백으로 변환

## 4. 내 코드 구현
```java
class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        String[] answer = new String[n];
        
        // arr1을 먼저 맵으로 변경하면
        int[][] map = new int[n][n];
        
        for(int i = 0; i < n; i++){
            int arr = arr1[i];
            for(int j = n-1; j>=0;j--){
                map[i][j] = arr%2;
                arr /=2;
            }
        }
        
        // arr2
        for(int i = 0; i<n ; i++){
            int arr = arr2[i];
            for(int j = n-1; j>=0 ; j--){
                if(map[i][j] != 1){
                    map[i][j] = arr%2;
                }
                arr /=2;
            }
        }
        
        for(int i = 0; i< n; i++){
            answer[i]= "";
            for(int j = 0; j<n; j++){
                answer[i] += (map[i][j] ==1)? "#" : " ";
            }
        }
        
        
        return answer;
    }
}
```

## 4. 다른 풀이(비트연산|)
```java
class Solution {
    public String[] solution(int n, int[] arr1, int[] arr2) {
        String[] answer = new String[n];
        
        for(int i= 0; i< n ; i++){
            // 1. 두 지도의 숫자를 비트 OR 연산으로 함칩
            // 예: 9(01001) | 30(11110) = 31(11111)
            // Integer.toBinaryString()은 2진수로 변환
            String binary = Integer.toBinaryString(arr1[i] | arr2[i]);
            
            // 2. 자릴수 맞추기(앞에 0 채우기)
            // n =5 인데 binary가 "1001"이면 " 1001"로 만든 뒤 0으로 바꿈
            binary = String.format("%" + n + "s", binary);

            // 3. 1.은 '#', 0은 ' '로 치환
            answer[i] = binary.replace("1", "#").replace("0", " ");
        }
        
        return answer;
    }
}
```