# 리코쳇 로봇 (Java)

## 문제 설명
격자판 위에서 로봇을 상, 하, 좌, 우 네 방향 중 하나로 이동시킵니다. 로봇은 장애물이나 격자판의 가장자리에 부딪힐 때까지 **미끄러지듯 이동**합니다. 목표 지점에 도달하기 위한 최소 이동 횟수를 구하는 문제입니다.

## 풀이 전략
1.  **BFS (너비 우선 탐색)**: "최소 이동 횟수"를 구하는 문제이므로 최단 경로를 보장하는 BFS가 적합합니다.
2.  **미끄러짐 구현**: `while` 루프를 사용하여 장애물(`D`)이나 벽을 만나기 전까지 좌표를 계속 이동시킵니다.
3.  **방문 처리**: 단순히 지나가는 경로가 아닌, 로봇이 **멈춰 선 위치(Stop Point)**를 기준으로 `visited[r][c]`를 체크합니다.
4.  **도달 불가능 판단**: 큐가 비어 모든 경우의 수를 탐색했음에도 불구하고 목표 지점(`G`)에 도달하지 못했다면 `-1`을 반환합니다.

## Java 구현 코드

```java
import java.util.*;

class Solution {
    // 이동 방향: 상, 하, 좌, 우
    int[] dr = {-1, 1, 0, 0};
    int[] dc = {0, 0, -1, 1};

    static class Node {
        int r, c, count;
        Node(int r, int c, int count) {
            this.r = r;
            this.c = c;
            this.count = count;
        }
    }

    public int solution(String[] board) {
        int n = board.length;
        int m = board[0].length();
        
        int startR = -1, startC = -1;
        
        // 1. 시작 지점(R) 찾기
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i].charAt(j) == 'R') {
                    startR = i;
                    startC = j;
                    break;
                }
            }
        }

        return bfs(board, startR, startC, n, m);
    }

    private int bfs(String[] board, int startR, int startC, int n, int m) {
        Queue<Node> queue = new LinkedList<>();
        boolean[][] visited = new boolean[n][m];
        
        queue.add(new Node(startR, startC, 0));
        visited[startR][startC] = true;

        while (!queue.isEmpty()) {
            Node curr = queue.poll();

            // 목표 지점(G)에서 멈췄는지 확인
            if (board[curr.r].charAt(curr.c) == 'G') {
                return curr.count;
            }

            for (int i = 0; i < 4; i++) {
                int nr = curr.r;
                int nc = curr.c;

                // 2. 미끄러짐: 벽이나 장애물을 만날 때까지 해당 방향으로 이동
                while (true) {
                    int nextR = nr + dr[i];
                    int nextC = nc + dc[i];

                    if (nextR < 0 || nextR >= n || nextC < 0 || nextC >= m 
                        || board[nextR].charAt(nextC) == 'D') {
                        break;
                    }
                    nr = nextR;
                    nc = nextC;
                }

                // 3. 멈춘 위치가 방문하지 않은 곳이라면 큐에 추가
                if (!visited[nr][nc]) {
                    visited[nr][nc] = true;
                    queue.add(new Node(nr, nc, curr.count + 1));
                }
            }
        }

        // 4. 모든 경로 탐색 후 목표 도달 불가 시 -1
        return -1;
    }
}
```

## 핵심 요약
- **목표 도달 불가**: BFS 탐색 루프가 끝난 후에도 `G`를 만나지 못해 루프 밖으로 빠져나오면 `-1`을 반환하게 설정하는 것이 포인트입니다.
- **멈춘 곳 기준**: 리코쳇 로봇의 규칙상 "중간에 멈출 수 없다"는 점을 고려하여 `while`문이 끝난 `nr`, `nc` 좌표만 큐에 넣는 것이 핵심입니다.
