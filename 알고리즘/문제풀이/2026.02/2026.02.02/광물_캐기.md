# [프로그래머스] 광물 캐기 - Java

- **날짜**: 2026-02-02
- **카테고리**: 그리디(Greedy), 정렬

---

## 1. 문제 설명
주어진 곡괭이들로 광물을 순서대로 캐야 합니다. 한 번 곡괭이를 선택하면 연속으로 5개의 광물을 캐야 하며, 각 곡괭이별로 광물에 따라 소모되는 피로도가 다릅니다. 최소한의 피로도로 모든 광물을(또는 곡괭이가 다 떨어질 때까지) 캐는 방법을 찾아야 합니다.

---

## 2. 해결 전략 (Greedy)
이 문제의 핵심은 **"가장 힘든 구간에 가장 좋은 곡괭이를 먼저 쓰는 것"**입니다.

1.  **제한 확인**: 곡괭이 개수가 부족할 수 있으므로, 우리가 가진 곡괭이로 캘 수 있는 최대 광물 수만큼만 광물 리스트를 자릅니다. (뒷부분은 정렬에 포함되면 안 됨)
2.  **묶음 생성**: 광물을 5개씩 묶어 각 묶음에 다이아몬드, 철, 돌이 각각 몇 개 있는지 파악합니다.
3.  **가치 기준 정렬**: 
    - 다이아몬드가 많은 순서대로, 
    - 다이아몬드가 같다면 철이 많은 순서대로 정렬합니다. 
    - 이는 곧 **'돌 곡괭이로 캤을 때 피로도가 가장 높은 순서'**와 같습니다.
4.  **곡괭이 할당**: 정렬된 묶음들에 다이아몬드 -> 철 -> 돌 곡괭이 순서대로 배정하며 피로도를 계산합니다.

---

## 3. 최종 코드

```java
import java.util.*;

class Solution {
    public int solution(int[] picks, String[] minerals) {
        int answer = 0;
        
        // 1. 전체 곡괭이 개수 파악
        int totalPicks = Arrays.stream(picks).sum();

        // 2. 캘 수 있는 최대 광물 수까지만 고려 (중요!)
        int limit = Math.min(minerals.length, totalPicks * 5);
        
        List<int[]> list = new ArrayList<>();
        for(int i = 0; i < limit; i += 5) {
            int diamond = 0, iron = 0, stone = 0;
            
            // 5개씩 묶어서 광물 개수 파악
            // i+5를 기준으로 범위를 잡아야 함
            for(int j = i; j < Math.min(i + 5, limit); j++) {
                if(minerals[j].equals("diamond")) diamond++;
                else if(minerals[j].equals("iron")) iron++;
                else stone++;
            }
            list.add(new int[]{diamond, iron, stone});
        }
        
        // 3. 정렬 (다이아 -> 철 -> 돌 많은 순으로)
        Collections.sort(list, (o1, o2) -> {
            if(o1[0] != o2[0]) return o2[0] - o1[0];
            if(o1[1] != o2[1]) return o2[1] - o1[1];
            return o2[2] - o1[2];
        });
        
        // 4. 곡괭이 배정 및 피로도 합산     
        for(int[] m : list) {
            int d = m[0], ir = m[1], s = m[2];
            
            if(picks[0] > 0) { // 다이아 곡괭이
                answer += d + ir + s;
                picks[0]--;
            } else if(picks[1] > 0) { // 철 곡괭이
                answer += (5 * d) + ir + s;
                picks[1]--;
            } else if(picks[2] > 0) { // 돌 곡괭이
                answer += (25 * d) + (5 * ir) + s;
                picks[2]--;
            }
        }
            
        return answer;
    }
}
```

---

## 4. 핵심 정리
- **왜 5개씩 묶는가?**: 곡괭이 사용 단위가 5개이기 때문입니다.
- **왜 캘 수 있는 것만 자르는가?**: 곡괭이가 모자라 못 캐는 광물 묶음이 정렬에 포함되어 "가장 힘든 구역"으로 판단되면, 정작 앞에 있는 힘든 구역에 써야 할 좋은 곡괭이를 뒤로 낭비하게 됩니다.
- **그리디의 타당성**: 광물의 가치(피로도 가중치)가 **1, 5, 25**로 5배씩 차이가 나기 때문에, 상위 광물이 많은 곳에 상위 곡괭이를 쓰는 것이 항상 최적의 해가 됩니다.
