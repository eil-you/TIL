# 🕰️ [알고리즘 정리] 아날로그 시계 (PCCP 기출)

## 1. 문제 핵심 요약
*   **목표**: 주어진 시작 시간(`h1:m1:s1`)부터 종료 시간(`h2:m2:s2`)까지 **초침이 시침 또는 분침과 겹치는(추월하는) 횟수**를 구하는 문제.
*   **특징**: 시, 분, 초침은 모두 각자의 속도로 끊임없이 움직이는 아날로그 방식임.

## 2. 해결을 위한 주요 포인트

### ① 시간의 단일화 (Total Seconds)
시, 분, 초를 각각 다루면 계산이 복잡하므로, 00:00:00을 기준으로 흐른 **'총 초(sec)'** 단위로 변환합니다.
*   `TotalSec = (h * 3600) + (m * 60) + s`

### ② 초당 이동 각도 계산
시계의 한 바퀴는 360도입니다. 각 바늘의 초당 이동 각도는 다음과 같습니다.
*   **초침**: 60초에 360도 → **6°/sec**
*   **분침**: 3600초에 360도 → **0.1°/sec**
*   **시침**: 43200초(12시간)에 360도 → **(360/43200) = 1/120°/sec** (약 0.00833°/sec)

### ③ 추월(겹침) 판단 로직 (Simulation)
1초 간격으로 시뮬레이션을 돌리며 **$T$초와 $T+1$초 사이**의 각도 변화를 관찰합니다.
*   **조건**: `$T$초일 때 (초침 < 시/분침)` 이고 `$T+1$초일 때 (초침 >= 시/분침)` 이면 추월 발생.
*   **경계값 처리**: 초가 넘어갈 때 각도가 0도로 초기화되는 문제를 해결하기 위해, `T+1` 시점의 각도가 0도라면 **360도**로 치환하여 비교합니다.

### ④ 예외 상황 (Edge Cases)
1.  **시작 시점 겹침**: 시작하는 그 순간에 이미 겹쳐 있다면 1을 더하고 시작해야 합니다.
2.  **동시 추월 (12시/0시 정각)**: 초침이 시침과 분침을 동시에 지나가는 시점입니다. 이때는 `answer`를 2가 아닌 **1만** 증가시켜야 합니다.
3.  **정밀도 문제**: `double` 연산 시 미세한 오차가 발생할 수 있습니다. (예: `1/120`도 계산 등)
    *   *Tip*: 모든 각도에 **120을 곱해서** 정수 연산을 수행하면 오차 없이 완벽하게 해결 가능합니다.

---

## 3. 핵심 코드 구조 (Java)

```java
class Solution {
    public int solution(int h1, int m1, int s1, int h2, int m2, int s2) {
        int answer = 0;
        int start = (h1 * 3600) + (m1 * 60) + s1;
        int end = (h2 * 3600) + (m2 * 60) + s2;

        // 시작 시점 겹침 체크
        if (isOverlap(start)) answer++;

        for (int i = start; i < end; i++) {
            double sNow = getSAngle(i), sNext = getSAngle(i + 1);
            double mNow = getMAngle(i), mNext = getMAngle(i + 1);
            double hNow = getHAngle(i), hNext = getHAngle(i + 1);

            // 360도 보정 (0 -> 360)
            if (sNext == 0) sNext = 360;
            if (mNext == 0) mNext = 360;
            if (hNext == 0) hNext = 360;

            boolean crossH = (sNow < hNow && sNext >= hNext);
            boolean crossM = (sNow < mNow && sNext >= mNext);

            if (crossH) answer++;
            if (crossM) answer++;
            
            // 시/분침 동시 추월 시 중복 제거 (정각 등)
            if (crossH && crossM && hNext == mNext) answer--;
        }
        return answer;
    }

    // 각도 계산 함수 (정밀도를 위해 double 사용 및 360도 나머지 연산)
    private double getSAngle(int s) { return (s * 6.0) % 360; }
    private double getMAngle(int s) { return (s * 0.1) % 360; }
    private double getHAngle(int s) { return (s * (1.0 / 120.0)) % 360; }
    
    private boolean isOverlap(int s) {
        // 부동 소수점 비교를 위해 아주 작은 값을 사용하거나 정수 변환 추천
        return Math.abs(getSAngle(s) - getHAngle(s)) < 1e-9 || Math.abs(getSAngle(s) - getMAngle(s)) < 1e-9;
    }
}
```

---

## 4. 요약 및 교훈
*   **문제를 쪼개자**: 복잡한 아날로그 움직임을 1초 단위의 **'이동 전/후 상태 비교'**로 단순화하는 것이 핵심입니다.
*   **경계값 보정**: 시계 문제처럼 '한 바퀴(0~360)'를 도는 문제는 **0도와 360도를 번갈아 생각**해야 하는 경우가 많습니다.
*   **정밀도 주의**: 실수 연산 비교(`==`, `>=`)를 할 때는 항상 오차 범위를 염두에 두거나, 정수 연산으로 변환 가능한지 검토해야 합니다.
