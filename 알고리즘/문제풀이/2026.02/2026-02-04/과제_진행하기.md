# ğŸ“‹ [ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬] ê³¼ì œ ì§„í–‰í•˜ê¸° (Stack / ìŠ¤ì¼€ì¤„ë§)

## 1. ë¬¸ì œ í•µì‹¬ ìš”ì•½
*   **ëª©í‘œ**: ì£¼ì–´ì§„ ê³¼ì œ ë¦¬ìŠ¤íŠ¸(`plans`)ë¥¼ ê·œì¹™ì— ë”°ë¼ ì§„í–‰í•˜ê³ , ì™„ë£Œëœ ìˆœì„œëŒ€ë¡œ ì´ë¦„ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œ.
*   **í•µì‹¬ ê·œì¹™**:
    *   ìƒˆë¡œìš´ ê³¼ì œ ì‹œì‘ ì‹œê°ì´ ë˜ë©´ í˜„ì¬ í•˜ë˜ ê³¼ì œë¥¼ ë©ˆì¶”ê³  ìƒˆ ê³¼ì œë¥¼ ì‹œì‘í•¨ (**ì„ ì í˜• ìŠ¤ì¼€ì¤„ë§**).
    *   ê³¼ì œë¥¼ ì™„ë£Œí–ˆì„ ë•Œ, ì ì‹œ ë©ˆì¶˜ ê³¼ì œ ì¤‘ **ê°€ì¥ ìµœê·¼ì— ë©ˆì¶˜ ê³¼ì œ**ë¶€í„° ë‹¤ì‹œ ì‹œì‘í•¨ (**LIFO - Stack í™œìš©**).

## 2. í•´ê²°ì„ ìœ„í•œ í•µì‹¬ ì „ëµ

### â‘  ì‹œê°„ ë‹¨ìœ„ ë‹¨ì¼í™”
*   "hh:mm" í˜•ì‹ì˜ ì‹œê°„ì„ ê³„ì‚°í•˜ê¸° í¸í•˜ë„ë¡ **ì´ ë¶„(minute)** ë‹¨ìœ„ì˜ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    *   `TotalMin = (hh * 60) + mm`

### â‘¡ ì •ë ¬ (Sorting)
*   ê³¼ì œëŠ” ì‹œì‘ ì‹œê°ì´ ë¹ ë¥¸ ìˆœì„œëŒ€ë¡œ ë“¤ì–´ì™€ì•¼ ì²˜ë¦¬ ë¡œì§ì´ ë‹¨ìˆœí•´ì§‘ë‹ˆë‹¤.
    *   `plans`ë¥¼ `startTime` ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤.

### â‘¢ ì‹œë®¬ë ˆì´ì…˜ ë¡œì§ (Current Time ê´€ë¦¬)
*   `currTime`(ì‹œìŠ¤í…œ ì‹œê³„) ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ íë¥¸ ì‹œê°„ë§Œí¼ ê³¼ì œë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
*   ìƒˆ ê³¼ì œê°€ ë“¤ì–´ì˜¤ê¸° ì „ê¹Œì§€ì˜ ê°€ìš© ì‹œê°„(`newStartTime - currTime`)ê³¼ í˜„ì¬ ì‘ì—… ì¤‘ì¸ ê³¼ì œì˜ ë‚¨ì€ ì‹œê°„(`remainTime`)ì„ ë¹„êµí•©ë‹ˆë‹¤.
*   **ë¹„êµ ê²°ê³¼**:
    *   `finishTime > newStartTime`: ë‹¤ìŒ ê³¼ì œ ì‹œì‘ ì „ê¹Œì§€ ëª» ëëƒ„. ë‚¨ì€ ì‹œê°„(`finishTime - newStartTime`)ì„ ê³„ì‚°í•´ ë‹¤ì‹œ ìŠ¤íƒì— ë„£ìŠµë‹ˆë‹¤.
    *   `finishTime <= newStartTime`: ê³¼ì œ ì™„ë£Œ. `currTime`ì„ `finishTime`ìœ¼ë¡œ ê°±ì‹ í•˜ê³  ìŠ¤íƒì—ì„œ ë‹¤ìŒ ë©ˆì¶˜ ê³¼ì œë¥¼ êº¼ë‚´ ìˆ˜í–‰í• ì§€ ê²°ì •í•©ë‹ˆë‹¤.

---

## 3. í•µì‹¬ ì½”ë“œ êµ¬ì¡° (Java)

```java
import java.util.*;

class Solution {
    public String[] solution(String[][] plans) {
        String[] answer = new String[plans.length];
        Arrays.sort(plans, (a, b) -> getTotalMin(a[1]) - getTotalMin(b[1]));
        
        Stack<String[]> stack = new Stack<>();
        int idx = 0, currTime = 0;

        for (int i = 0; i < plans.length; i++) {
            int startTime = getTotalMin(plans[i][1]);
            int playTime = Integer.parseInt(plans[i][2]);

            // ìƒˆ ê³¼ì œ ì‹œì‘ ì „, ë©ˆì¶˜ ê³¼ì œë“¤ ì²˜ë¦¬
            while (!stack.isEmpty()) {
                String[] s = stack.pop();
                int finishTime = currTime + Integer.parseInt(s[1]);

                if (finishTime > startTime) { // ì¤‘ë‹¨í•´ì•¼ í•¨
                    stack.push(new String[]{s[0], String.valueOf(finishTime - startTime)});
                    break;
                } else { // ì™„ë£Œí•¨
                    answer[idx++] = s[0];
                    currTime = finishTime;
                }
            }
            stack.push(new String[]{plans[i][0], String.valueOf(playTime)});
            currTime = startTime;
        }

        while (!stack.isEmpty()) answer[idx++] = stack.pop()[0];
        return answer;
    }
    
    private int getTotalMin(String time) {
        String[] p = time.split(":");
        return Integer.parseInt(p[0]) * 60 + Integer.parseInt(p[1]);
    }
}
```

---

## 4. ì˜¤ë‹µ ë…¸íŠ¸ & êµí›ˆ
*   **Stack ì„ íƒ ì´ìœ **: "ê°€ì¥ ìµœê·¼ì— ë©ˆì¶˜ ê²ƒë¶€í„° ì¬ê°œ"ë¼ëŠ” ì¡°ê±´ì´ ë°”ë¡œ í›„ì…ì„ ì¶œ(LIFO)ì˜ íŠ¹ì§•ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
*   **ì‹œê°„ ê°±ì‹ **: ê³¼ì œë¥¼ ì™„ë£Œí–ˆì„ ë•Œ `currTime = finishTime`ìœ¼ë¡œ ê°±ì‹ í•´ì¤˜ì•¼, ë‚¨ëŠ” ì‹œê°„ ë™ì•ˆ ìŠ¤íƒì˜ ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë¡œì§ì´ ì •í™•íˆ ì‘ë™í•©ë‹ˆë‹¤.
*   **ìˆ˜ì‹ ì£¼ì˜**: ë‚¨ì€ ì‹œê°„ ê³„ì‚° ì‹œ `ì „ì²´ - ì‘ì—…í•œ ì‹œê°„` ëŒ€ì‹  `ì¢…ë£Œ ì˜ˆì • ì‹œê° - ê°•ì œ ì¤‘ë‹¨ ì‹œê°`ìœ¼ë¡œ ì ‘ê·¼í•˜ëŠ” ê²ƒì´ ì§ê´€ì ì…ë‹ˆë‹¤.
