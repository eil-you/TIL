# 🚀 [알고리즘 정리] 요격 시스템 (Greedy)

## 1. 문제 핵심 요약
*   **목표**: $x$축에 평행한 여러 개의 폭격 미사일 구간 $(s, e)$이 주어질 때, 모든 미사일을 요격하기 위해 필요한 **최소한의 요격 미사일 수**를 구하는 문제.
*   **조건**: 요격 미사일은 특정 $x$ 좌표에서 수직으로 발사하며, 해당 $x$가 $s < x < e$인 모든 폭격 미사일을 한 번에 요격함. (경계값 포함 안 함)

## 2. 해결을 위한 핵심 전략: Greedy (탐욕법)

### ① 왜 Greedy인가?
현재 상황에서 **가장 빨리 끝나는 미사일을 기준으로 요격**하면, 그 요격 미사일이 뒤에 오는 다른 미사일들도 함께 관통할 확률이 가장 높기 때문입니다. 이는 클래식한 **"회의실 배정 문제"** 또는 **"활동 선택 문제"**와 같은 원리입니다.

### ② 정렬 (Sorting) — **가장 중요** ⭐️
반드시 **끝나는 지점($e$)**을 기준으로 오름차순 정렬해야 합니다.
*   끝나는 지점이 같다면 시작 지점은 크게 상관없으나, 보통은 시작 지점도 오름차순으로 정렬합니다.

### ③ 탐욕적 선택 (Linear Scan)
정렬된 미사일들을 순차적으로 확인하며 요격 위치를 갱신합니다.
*   `lastShot`: 마지막으로 요격 미사일을 쏜 위치.
*   새 미사일의 시작 지점이 `lastShot`보다 크거나 같다면 (`start >= lastShot`), 이전 미사일로는 현재 미사일을 맞출 수 없으므로 **새로운 요격 미사일을 발사**해야 합니다.
*   새로운 요격 위치는 현재 미사일이 끝나기 직전(가장 뒤쪽)인 `end` 지점으로 갱신합니다.

---

## 3. 핵심 코드 구조 (Java)

```java
import java.util.*;

class Solution {
    public int solution(int[][] targets) {
        int answer = 0;
        
        // 1. 끝 지점(target[1]) 기준 오름차순 정렬
        Arrays.sort(targets, (a, b) -> a[1] - b[1]);
        
        int lastShot = -1; // 마지막 요격 위치
        
        for (int[] target : targets) {
            int s = target[0];
            int e = target[1];
            
            // 2. 현재 미사일의 시작점이 마지막 요격 위치보다 뒤에 있으면 새로 발사
            if (s >= lastShot) {
                answer++;
                lastShot = e; // 가장 효율적인 위치인 끝점으로 갱신
            }
        }
        
        return answer;
    }
}
```

---

## 4. 오답 노트 & 교훈
*   **정렬의 부재**: 정렬하지 않고 순서대로 처리하면, 나중에 오는 짧은 구간의 미사일을 놓치게 되어 최소 개수를 구할 수 없습니다.
*   **시간 복잡도**: $N$이 최대 50만인 경우, $O(N^2)$ 접근은 불가능합니다. 정렬($O(N \log N)$) 후 한 번의 순회($O(N)$)로 끝내는 최적화가 필요합니다.
*   **경계값 처리**: 문제에서 개구간 $(s, e)$이라고 명시했으므로, $x$가 $s$와 같거나 $e$와 같으면 요격되지 않습니다. 코드에서 `s >= lastShot` 조건을 사용하는 이유입니다.
