# [프로그래머스] 연속된 부분 수열의 합 - Java

- **날짜**: 2026-02-02
- **카테고리**: 투 포인터, 슬라이딩 윈도우

---

## 1. 문제 설명
비내림차순으로 정렬된 수열 `sequence`와 정수 `k`가 주어질 때, 다음 조건을 만족하는 부분 수열의 시작 인덱스와 끝 인덱스를 구하는 문제입니다.
1. 부분 수열의 합은 `k`여야 합니다.
2. 합이 `k`인 부분 수열이 여러 개라면 길이가 가장 짧은 수열을 찾습니다.
3. 길이까지 같다면 시작 인덱스가 가장 작은 수열을 찾습니다.

---

## 2. 나의 풀이 (초기 접근)
투 포인터를 활용하여 합이 `k`인 구간을 찾고, 해당 구간들을 `HashMap`에 저장한 뒤 마지막에 최소 길이를 찾는 방식입니다.

```java
import java.util.*;

class Solution {
    public int[] solution(int[] sequence, int k) {
        int[] answer = new int[2];
        // Map<시작인덱스, 끝나는인덱스>
        Map<Integer, Integer> map = new HashMap<>();
        
        int sum = 0;
        int left = 0;
        for(int i = 0; i < sequence.length; i++){
            sum += sequence[i];
            while(sum > k){
                sum -= sequence[left++];
            }
            
            if(sum == k){
                map.put(left, i);
            }
        }
        
        int len = Integer.MAX_VALUE;
        for(int key : map.keySet()){
            if(map.get(key) - key < len){
                len = map.get(key) - key;
                answer[0] = key;
                answer[1] = map.get(key);
            }
        }
        
        return answer;
    }
}
```

---

## 3. 피드백 및 최적화

### 주요 피드백
1. **HashMap 순서 문제**: `HashMap`은 키의 순서를 보장하지 않습니다. "길이가 같을 때 시작 인덱스가 작은 것"을 뽑아야 하는 조건에서, `keySet()` 순회 시 인덱스가 순서대로 나오지 않아 잘못된 값이 선택될 위험이 있습니다.
2. **불필요한 메모리 사용**: 모든 구간을 `Map`에 담아둘 필요 없이, 반복문을 돌면서 즉시 최소 길이를 갱신(On-the-fly)하는 것이 효율적입니다.

### 최적화된 코드
`Map`을 제거하고 `len` 변수를 통해 실시간으로 정답을 갱신합니다.

```java
class Solution {
    public int[] solution(int[] sequence, int k) {
        int[] answer = new int[2];
        int minLen = Integer.MAX_VALUE;
        
        int sum = 0;
        int left = 0;
        
        for (int right = 0; right < sequence.length; right++) {
            sum += sequence[right];
            
            while (sum > k) {
                sum -= sequence[left++];
            }
            
            if (sum == k) {
                int currentLen = right - left;
                // 더 짧은 길이를 찾았을 때만 갱신
                // left가 순차적으로 증가하므로, 작을 때만 교체하면 
                // 길이가 같을 경우 앞선 인덱스가 자동으로 유지됨
                if (currentLen < minLen) {
                    minLen = currentLen;
                    answer[0] = left;
                    answer[1] = right;
                }
            }
        }
        
        return answer;
    }
}
```

---

## 4. 핵심 정리
- **투 포인터 (Two Pointers)**: 수열이 정렬되어 있을 때 두 개의 포인터를 조절하며 구간의 합을 효율적으로 구할 수 있습니다. ($O(N)$)
- **비교 로직**: 길이가 같을 때의 조건을 처리하기 위해 `currentLen < minLen`처럼 엄격하게 작은 경우에만 갱신하도록 설계하면, 먼저 발견된(인덱스가 작은) 데이터가 자연스럽게 최종 정답이 됩니다.
