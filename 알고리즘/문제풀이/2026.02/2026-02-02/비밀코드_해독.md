# [프로그래머스] 비밀코드 해독 - Java

- **날짜**: 2026-02-02
- **카테고리**: 브루트 포스, 백트래킹, 조합(Combination)

---

## 1. 문제 설명
1부터 `n`까지의 숫자 중 서로 다른 5개를 오름차순으로 고른 '비밀코드'를 찾아야 합니다. 
여러 번의 시도(`q`)와 각 시도에서 맞은 숫자의 개수(`ans`)가 주어질 때, 모든 조건을 만족하는 가능한 비밀코드의 조합 개수를 구하는 문제입니다.

---

## 2. 나의 풀이 (HashSet 기반)
처음에는 중복 없는 조합을 생성하고, 포함 여부를 빠르게 확인하기 위해 `HashSet`을 활용했습니다.

```java
import java.util.*;

class Solution {
    int answer = 0;
    public int solution(int n, int[][] q, int[] ans) {
        HashSet<Integer> set = new HashSet<>();
        dfs(0, 1, n, set, q, ans);
        return answer;
    }
    
    private void dfs(int L, int start, int n, HashSet<Integer> set, int[][] q, int[] ans){    
        if(L == 5){
            if(isOk(set, q, ans)) answer++;
        } else {
            for(int i = start; i <= n; i++){
                set.add(i);
                dfs(L + 1, i + 1, n, set, q, ans);
                set.remove(i);
            }
        }
    }
    
    private boolean isOk(HashSet<Integer> pickNumber, int[][] q, int[] ans){
        for(int i = 0; i < ans.length; i++){
            int[] qq = q[i];
            int sameCnt = 0;
            for(int j = 0; j < 5; j++){
                if(pickNumber.contains(qq[j])) sameCnt++;
            }
            if(sameCnt != ans[i]) return false;
        }
        return true;
    }
}
```

---

## 3. 추가 최적화 포인트 (Optimized)

### 1) 탐색 범위 가지치기 (Pruning)
단순히 `i <= n`까지 돌리는 것이 아니라, 남은 숫자의 개수가 내가 더 뽑아야 할 숫자의 개수보다 적으면 루프를 미리 종료합니다.
- 공식: `i <= n - (원하는개수 - 현재개수) + 1`
- 이 문제의 경우: `i <= n - (5 - L) + 1`

### 2) HashSet 대신 배열 활용
값의 범위가 1~30으로 협소하므로, `HashSet` 대신 `boolean[]` 배열을 사용합니다.
- `HashSet.contains()`: 해시 함수 계산 및 객체 참조 비용 발생
- `boolean[] picked`: 인덱스를 통한 직접 접근 (메모리 성능 및 속도 우위)

### 3) 최적화된 코드

```java
import java.util.*;

class Solution {
    int answer = 0;
    
    public int solution(int n, int[][] q, int[] ans) {
        // 1~n 까지의 숫자 선택 여부를 기록할 배열
        boolean[] picked = new boolean[n + 1];
        dfs(0, 1, n, picked, q, ans);
        return answer;
    }
    
    private void dfs(int L, int start, int n, boolean[] picked, int[][] q, int[] ans){    
        if(L == 5){
            if(isOk(picked, q, ans)) answer++;
            return;
        }

        // 가지치기: i <= n - (4 - L)
        for(int i = start; i <= n - (4 - L); i++){
            picked[i] = true;
            dfs(L + 1, i + 1, n, picked, q, ans); 
            picked[i] = false;
        }
    }
    
    private boolean isOk(boolean[] picked, int[][] q, int[] ans){
        for(int i = 0; i < ans.length; i++){
            int sameCnt = 0;
            for(int num : q[i]){
                if(picked[num]) sameCnt++;
            }
            if(sameCnt != ans[i]) return false;
        }
        return true;
    }
}
```

---

## 4. 핵심 정리 및 교훈
- **Pruning의 위력**: 작은 데이터셋에서는 큰 차이가 없어도, 대규모 데이터셋에서는 탐색 공간을 절반 이하로 줄여주는 핵심 기법입니다.
- **자료구조의 선택**: 무조건 `Collection`을 쓰기보다, 데이터의 범위가 정해져 있다면 **Primitive Array(기본형 배열)**를 쓰는 것이 성능상 최선입니다.
- **백트래킹의 정석**: 상태 변경 -> 재귀 호출 -> 상태 복구의 흐름을 명확히 이해해야 합니다.
