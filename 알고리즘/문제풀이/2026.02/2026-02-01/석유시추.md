# 석유시추

## 1. 문제 설명
세로길이가 n 가로길이가 m인 격자 모양의 땅 속에서 석유가 발견되었습니다. 석유는 여러 덩어리로 나누어 묻혀있습니다. 당신이 시추관을 수직으로 단 하나만 뚫을 수 있을 때, 가장 많은 석유를 뽑을 수 있는 시추관의 위치를 찾으려고 합니다. 시추관은 열 하나를 관통하는 형태여야 하며, 열과 열 사이에 시추관을 뚫을 수 없습니다.

 만약 시추관이 석유 덩어리의 일부를 지나면 해당 덩어리에 속한 모든 석유를 뽑을 수 있습니다. 시추관이 뽑을 수 있는 석유량은 시추관이 지나는 석유 덩어리들의 크기를 모두 합한 값입니다. 시추관을 설치한 위치에 따라 뽑을 수 있는 석유량은 다음과 같습니다.    

| 시추관의 위치	획득한 덩어리	총 석유량 |
| --- | --- | --- |
| 1	[8]	8 |
| 2	[8]	8 |
| 3	[8]	8 |
| 4	[7]	7 |
| 5	[7]	7 |
| 6	[7]	7 |
| 7	[7, 2]	9 |
| 8	[2]	2 |
오른쪽 그림처럼 7번 열에 시추관을 설치하면 크기가 7, 2인 덩어리의 석유를 얻어 뽑을 수 있는 석유량이 9로 가장 많습니다.

석유가 묻힌 땅과 석유 덩어리를 나타내는 2차원 정수 배열 land가 매개변수로 주어집니다. 이때 시추관 하나를 설치해 뽑을 수 있는 가장 많은 석유량을 return 하도록 solution 함수를 완성해 주세요.

### 매개변수
- int[][] land : 석유가 묻힌 땅과 석유 덩어리를 나타내는 2차원 정수 배열

### 반환값
- int : 시추관 하나를 설치해 뽑을 수 있는 가장 많은 석유량

### 제한 사항
- 1 <= land의 길이 = 땅의 세로길이 = n <= 500
    - 1 <= land의 너비 = 땅의 가로길이 = m <= 500
    - land[i][j]는 0 또는 1로 구성
    - land[i][j] = 1인 경우 석유가 묻힌 땅
    - land[i][j] = 0인 경우 석유가 묻히지 않은 땅

### 입출력 예
| land | result |
| --- | --- |
| [[0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1]] | 9 |
| [[1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]] | 16 |
## 2. 문제 풀이
1. land를 돌면서 1인 곳이면 bfs로 덩어리 id를 매겨줍니다.
    - visited를 사용하여 bfs를 돌았는지 확인합니다.
    - idMap에 덩어리 id를 적어놓습니다.
    - map에 덩어리 id와 덩어리 크기를 저장합니다.
2. 각 열이 가지는 최대 시추양 계산
    - 각 열을 돌면서 idMap을 확인하여 set에 저장
    - set에 저장된 id를 map에서 찾아서 size를 더해줍니다.
    - answer와 비교하여 큰 값을 answer에 저장합니다.
3. answer를 return합니다.



## 3. 코드 구현
```java
    class Solution{
        int[] dx = {-1, 1, 0, 0};
        int[] dy = {0, 0, -1, 1};

        boolean[][] visited; // bfs 돌았는지 확인하는 배열
        int[][] idMap; // 덩어리 id 적어놓는 배열

        int n; // row
        int m; // col

        boolean isValid(int x, int y){
            return x >= 0 && x < n && y >= 0 && y < m;
        }


        int bfs(int[][] land, int x, int y, int id){
            Queue<int[]> queue = new LinkedList<>();
            queue.add(new int[]{x, y});

            visited[x][y] = true;
            idMap[x][y] = id;
            
            int size = 1;
            while(!queue.isEmpty()){
                int[] cur = queue.poll();
                for(int i=0; i<4; i++){
                    int nx = cur[0] + dx[i];
                    int ny = cur[1] + dy[i];
                    if(isValid(nx, ny)&&!visited[nx][ny]&&land[nx][ny] != 0){
                        queue.add(new int[]{nx, ny});
                        visited[nx][ny] = true;
                        idMap[nx][ny] = id;
                        size++;
                    }
                }
            }
            return size;
        }

        public int solution(int[][] land){
            int answer = 0;

            n = land.length;
            m = land[0].length;

            visited = new boolean[n][m];
            idMap = new int[n][m];
            Map<Integer, Integer> map = new HashMap<>(); // 덩어리 id, 덩어리 size 
            
            // 덩어리 아이디
            int id = 1;

            // 덩어리 양 계산 하는 로직
            for(int i=0; i<n; i++){
                for(int j=0; j<m; j++){
                    if(!visited[i][j]&&land[i][j] != 0){
                        int size = bfs(land, i, j, id);
                        map.put(id++, size);
                    }
                }
            }

           
            // 각 열이 가지는 최대 시추양 계산
            for(int i = 0; i <m; i++){
                int colMaxOil = 0;
                Set<Integer> set = new HashSet<>();
                for(int j = 0; j < n; j++){
                    if(idMap[j][i] != 0){
                        set.add(idMap[j][i]);
                    }
                }    
                for(int number : set){
                    colMaxOil += map.get(number);
                }
                answer = Math.max(answer, colMaxOil);
            }

            return answer;
        }
    }
```

