# [카카오 인턴] 도넛과 막대 그래프 (2026-02-03)

## 1. 문제 개요
- **문제명**: 도넛과 막대 그래프
- **문제 유형**: 그래프, 차수 분석 (Degree Analysis)
- **핵심 목표**: 생성된 정점과 그에 연결된 도넛, 막대, 8자 그래프의 개수를 각각 파악함.

## 2. 핵심 아이디어: 정점의 차수(Degree) 활용
복잡한 그래프 탐색 대신, 각 모양이 가진 **기하학적 특징**을 정점의 들어오는 간선 ($In$)과 나가는 간선 ($Out$)의 개수로 구분합니다.

| 종류 | $In$ 개수 | $Out$ 개수 | 특징적인 정점의 역할 |
| :--- | :--- | :--- | :--- |
| **생성된 정점** | $0$ | $2$ 이상 | 모든 그래프를 하나씩 콕 집어서 나가는 간선을 가짐 |
| **막대 그래프** | $1$ 이상 | **$0$** | 막대의 가장 끝부분은 더 이상 나가는 곳이 없음 |
| **8자 그래프** | **$2$ 이상** | **$2$** | 가운데 교차점은 항상 상하좌우로 길이 나 있음 |
| **도넛 그래프** | - | - | 특이점이 없으므로 `전체 - (막대 + 8자)`로 계산 |

## 3. 해결 단계
1. **차수 카운트**: `edges`를 순회하며 모든 정점의 $In, Out$ 개수를 `Map`에 저장.
2. **범인(생성된 정점) 찾기**: $In=0, Out \ge 2$ 인 정점을 찾고, 그 정점의 $Out$ 개수를 전체 그래프 수로 저장.
3. **특이점 검색**:
   - $Out=0$ 인 정점이 보이면 막대 그래프 개수 +1.
   - $Out=2, In \ge 2$ 인 정점이 보이면 8자 그래프 개수 +1.
4. **최종 계산**: `전체 수 - 막대 수 - 8자 수 = 도넛 수`.

## 4. 최종 코드 (Java)
```java
import java.util.*;

class Solution {
    public int[] solution(int[][] edges) {
        int[] answer = new int[4];
        Map<Integer, Integer> inDegree = new HashMap<>();
        Map<Integer, Integer> outDegree = new HashMap<>();
        
        int maxNode = 0;
        for(int[] edge : edges){
            int out = edge[0];
            int in = edge[1];
            
            // maxNode 누적 갱신
            maxNode = Math.max(maxNode, Math.max(out, in));
            
            outDegree.put(out, outDegree.getOrDefault(out, 0) + 1);
            inDegree.put(in, inDegree.getOrDefault(in, 0) + 1);
        }
        
        for(int i = 1; i <= maxNode; i++){
            int in = inDegree.getOrDefault(i, 0);
            int out = outDegree.getOrDefault(i, 0);
            
            if(out >= 2 && in == 0) {
                answer[0] = i; // 생성된 정점
            }
            else if(out == 0 && in >= 1) {
                answer[2]++; // 막대 그래프
            }
            else if(out == 2 && in >= 2) {
                answer[3]++; // 8자 그래프
            }
        }
        
        // 도넛 그래프 = 전체 그래프 수 - 막대 - 8자
        int totalGraphs = outDegree.getOrDefault(answer[0], 0);
        answer[1] = totalGraphs - answer[2] - answer[3];
        
        return answer;
    }
}
```

## 5. 오늘의 교훈
- 그래프 문제라고 해서 항상 BFS/DFS가 정답은 아니다.
- 각 모양의 **불변하는 특징(차수 등)**을 찾아내면 시간 복잡도를 $O(N)$으로 혁신적으로 낮출 수 있다.
- 자바의 `Map`을 사용할 때는 `getOrDefault`를 생활화하여 에러를 방지하자.
