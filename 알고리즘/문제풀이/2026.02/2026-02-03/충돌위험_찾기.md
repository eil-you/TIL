# [PCCP 기출문제] 충돌위험 찾기 (2026-02-03)

## 1. 문제 개요
- **문제명**: [PCCP 기출문제] 충돌위험 찾기
- **문제 유형**: 시뮬레이션 (Simulation)
- **핵심 목표**: 여러 대의 로봇이 정해진 경로를 이동할 때, 특정 시간에 같은 좌표에 위치하여 발생하는 충돌의 총 횟수를 구함.

## 2. 해결 방법: 시뮬레이션 전략
이 문제는 로봇들을 실시간으로 하나씩 움직이기보다, **각 로봇의 전체 이동 경로를 시간 순서대로 미리 계산**해두는 것이 핵심입니다.

### 핵심 로직
1.  **경로 생성**: 각 로봇별로 `Queue<int[]>`를 생성하여 이동하는 모든 좌표를 저장합니다.
    - 이동 규칙: `r`(행) 좌표를 우선적으로 맞춘 후, `c`(열) 좌표를 이동합니다.
    - 매 초마다 한 칸씩 이동하므로 좌표를 하나씩 큐에 쌓습니다.
2.  **동시간대 충돌 체크**: 모든 로봇의 큐에서 같은 시간대의 위치를 꺼내 비교합니다.
    - `Map<String, Integer>`를 사용하여 특정 좌표(`"r,c"`)에 몇 대의 로봇이 있는지 카운트합니다.
    - 카운트가 2 이상인 좌표가 있다면 해당 시간의 충돌 횟수를 증가시킵니다.
3.  **종료 조건**: 모든 로봇이 자신의 목적지에 도착하여 운행을 마치면 시뮬레이션을 종료합니다.

## 3. 구현 코드 (Java)

```java
import java.util.*;

class Solution {
    public int solution(int[][] points, int[][] routes) {
        int answer = 0;
        // 각 로봇의 경로를 담을 리스트 (각 원소는 시간순 좌표 큐)
        List<Queue<int[]>> robotsPaths = new ArrayList<>();
        
        // 1. 모든 로봇의 전체 이동 경로 계산
        for(int[] route : routes) {
            Queue<int[]> queue = new LinkedList<>();
            
            // 시작 위치 설정 (1-indexed points 대응)
            int currR = points[route[0]-1][0];
            int currC = points[route[0]-1][1];
            queue.add(new int[]{currR, currC});
            
            // 경유지 순서대로 이동 경로 생성
            for(int i = 1; i < route.length; i++) {
                int goalR = points[route[i]-1][0];
                int goalC = points[route[i]-1][1];
               
                // R 좌표 먼저 이동 (수직 이동)
                while(currR != goalR) {
                    if(currR > goalR) currR--;
                    else currR++;
                    queue.add(new int[]{currR, currC});
                }
                
                // C 좌표 이동 (수평 이동)
                while(currC != goalC) {
                    if(currC > goalC) currC--; 
                    else currC++;
                    queue.add(new int[]{currR, currC});
                }
            }
            robotsPaths.add(queue);
        }
        
        // 2. 시간대별(t) 충돌 여부 시뮬레이션
        while(true) {
            Map<String, Integer> posMap = new HashMap<>();
            boolean allEmpty = true;
            
            for(int i = 0; i < robotsPaths.size(); i++) {
                Queue<int[]> q = robotsPaths.get(i);
                if (!q.isEmpty()) {
                    int[] pos = q.poll();
                    String key = pos[0] + "," + pos[1];
                    posMap.put(key, posMap.getOrDefault(key, 0) + 1);
                    allEmpty = false;
                }
            }
            
            // 모든 로봇이 운행을 종료했다면 루프 탈출
            if(allEmpty) break;
            
            // 3. 현재 시간(t)에 충돌 피해가 발생한 좌표의 개수 합산
            for(int count : posMap.values()) {
                if(count >= 2) answer++;
            }
        }
        
        return answer;
    }
}
```

## 4. 오늘의 학습 포인트
- **시뮬레이션 문제의 접근**: 복잡한 움직임은 데이터를 미리 구조화(경로 미리 계산)하면 로직이 훨씬 단순해진다.
- **좌표 문자열 연산**: 배열이나 객체를 Map의 키로 쓸 때는 `String`으로 변환하여 비교하는 것이 직관적이고 안전하다.
- **데이터 구조**: 로봇별 이동 시간이 다를 때 `Queue`를 활용하면 매 시간마다 순차적으로 상태를 뽑아 쓰기 매우 편리하다.
