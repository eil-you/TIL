# 소수찾기

## 1. 문제 설명
1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 완성해주세요.

## 제한 조건
- n은 2 이상 1000000 이하입니다.

## 2. 문제 풀이
1. 소수인지 판별하는 boolean[] 배열을 만들어, 소수와 소수의 배수를 제거해나가는 에라토스테네스의 체를 사용
2. 소수를 확인하는 함수 생성


## 3. 코드 풀이
```java
프록시 서버 문제는 잠시 내려두고 다시 코딩으로 돌아오셨군요! 이번에는 '소수 찾기(에라토스테네스의 체)' 알고리즘을 구현하셨네요.

작성하신 코드는 "이미 체크한 숫자는 건너뛴다"는 효율적인 접근 방식을 취하고 있지만, 세부적인 로직에서 몇 가지 치명적인 오류가 있어 결과가 제대로 나오지 않을 거예요. 하나씩 짚어드릴게요.

🔍 현재 코드의 문제점
isPrime 함수의 범위: i가 3부터 시작하고 i*i < n까지만 돌면, 2 같은 짝수 소수를 놓치게 되고 i*i == n인 경우(예: 9, 25)를 체크하지 못합니다.

배수 제거 로직 (check 배열): 사실 에라토스테네스의 체를 제대로 쓰면 isPrime 함수 자체가 필요 없습니다. 소수를 발견하면 그 배수들을 미리 true로 바꿔서 미래의 후보에서 지워버리는 원리니까요.

중복 연산: 현재 isPrime을 호출하면서 동시에 배수를 지우고 있는데, 체의 원리를 조금 더 깔끔하게 다듬으면 성능이 훨씬 좋아집니다.

🛠️ 에라토스테네스의 체 (정석 풀이)
이 방식은 마치 체로 치듯이 숫자를 걸러내는 방식입니다.

Java
class Solution {
    public int solution(int n) {
        int answer = 0;
        // 0부터 n까지 담아야 하므로 n+1 크기로 생성
        boolean[] isNotPrime = new boolean[n + 1]; 

        // 0과 1은 소수가 아님
        isNotPrime[0] = isNotPrime[1] = true;

        for (int i = 2; i <= n; i++) {
            // 아직 걸러지지 않았다면 그 숫자는 소수!
            if (!isNotPrime[i]) {
                answer++;
                
                // i의 배수들을 소수가 아닌 것으로 체크 (i*i부터 시작해도 됨)
                // i*j <= n 대신 i+i부터 시작해서 i씩 더해가는 게 더 빠름
                for (int j = i + i; j <= n; j += i) {
                    isNotPrime[j] = true;
                }
            }
        }

        return answer;
    }
}
```