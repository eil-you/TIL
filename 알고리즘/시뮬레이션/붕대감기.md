# [PCCP 기출문제] 1번 - 붕대 감기

## 1. 문제 설명
어떤 게임에는 **붕대 감기**라는 기술이 있습니다.

붕대 감기는 `t`초 동안 붕대를 감으면서 1초마다 `x`만큼의 체력을 회복합니다. `t`초 연속으로 붕대를 감는 데 성공한다면 `y`만큼의 체력을 추가로 회복합니다. 게임 캐릭터에는 최대 체력이 존재해 현재 체력이 최대 체력보다 커지는 것은 불가능합니다.

기술을 쓰는 도중 몬스터에게 공격을 당하면 기술이 취소되고, 공격을 당하는 순간에는 체력을 회복할 수 없습니다. 몬스터에게 공격당해 기술이 취소당하거나 기술이 끝나면 그 즉시 붕대 감기를 다시 사용하며, 연속 성공 시간이 0으로 초기화됩니다.

몬스터의 공격을 받으면 정해진 피해량만큼 현재 체력이 줄어듭니다. 이때, 현재 체력이 0 이하가 되면 캐릭터가 죽으며 더 이상 체력을 회복할 수 없습니다.

당신은 붕대감기 기술의 정보, 캐릭터가 가진 최대 체력과 몬스터의 공격 패턴이 주어질 때 캐릭터가 끝까지 생존할 수 있는지 궁금합니다.

### 매개변수
- `bandage`: 붕대 감기 기술의 [시전 시간, 1초당 회복량, 추가 회복량]을 담은 1차원 정수 배열
- `health`: 최대 체력을 의미하는 정수
- `attacks`: 몬스터의 공격 시간과 피해량을 담은 2차원 정수 배열

### 반환값
- 모든 공격이 끝난 직후 남은 체력을 return 합니다.
- 만약 몬스터의 공격을 받고 캐릭터의 체력이 0 이하가 되어 죽는다면 `-1`을 return 합니다.



## 2. 직접 코드 구현 (Java)

이 코드는 `modHealth` 메서드를 통해 각 초(second)마다 발생할 체력 변화량(회복 또는 피해)을 미리 계산하여 배열에 저장한 뒤, 최종 체력을 산출하는 **사전 계산(Pre-calculation)** 방식입니다.

```java
class Solution {
    public int solution(int[] bandage, int health, int[][] attacks) {
        // 최종 체력값
        int answer = health;
        
        // 최종 시간
        int finalTime = attacks[attacks.length-1][0];
        
        int[] mh = modHealth(bandage, attacks, finalTime);
        
        for(int i = 1; i<=finalTime; i++){
            
            answer+= mh[i];
            
            // 현재 체력과 최대체력이 같으면 스킵
            if(answer >= health) answer = health;
            
            
            // if(체력이 마이너스이면 -1)
            if(answer <=0){
                answer = -1;
                break;
            }
        }
 
        return answer;
    }
    
    
    // 각 시간마다 추가 체력과 피해체력
    private int[] modHealth(int[] bandage, int[][] attacks, int finalTime){
         int[]  answer = new int[finalTime+1];
        
        int continueCnt = 0;
        for(int[] x : attacks){
            answer[x[0]] = -x[1];
        }
        
        for(int i = 0; i <= finalTime ;i++ ){
            if(answer[i] <0) continueCnt = 0;
            else {
                if (i > 0) { // 0초 이후부터 회복 적용
                    answer[i] = bandage[1];
                    continueCnt++;
                    if(continueCnt == bandage[0]){
                        answer[i] += bandage[2];
                        continueCnt =0 ;
                    }
                }
            }
        }
        return answer;
    }
}
```

## 3. 참조 코드 (Java)


```java
class Solution {

    public int solution(int[] bandage, int health, int[][] attacks) {
        int cnt = bandage[0]; // 추가 체력 기준
        int now = health; // 현재 체력
        int std = 0; // 마지막으로 공격당한 시간

        int v1, v2; // 추가 체력 받을 수 있나?
        for (int[] atk: attacks) {
            if (now <= 0) {
                return -1;
            }

            v1 = atk[0] - std - 1; // 시간 차이
            v2 = v1 / cnt; // 추가 체력 회수

            // 맞기 직전까지의 체력 정산
            std = atk[0];
            now = Math.min(health, now + (v1 * bandage[1]));
            now = Math.min(health, now + (v2 * bandage[2]));

            now -= atk[1];
        }        

        return now <= 0 ? -1 : now;
    }
}
```
