# Dynamic Programming (동적 계획법, DP)

## 1. 동적 계획법이란?
동적 계획법(Dynamic Programming, DP)은 **큰 문제를 작은 문제로 나누어 해결하고**,  
그 결과를 저장(메모이제이션)하여 **중복 계산을 제거하는 알고리즘 기법**이다.

주로 **최적해(최댓값/최솟값/경우의 수)**를 구하는 문제에서 사용된다.

---

## 2. DP가 적용 가능한 조건

동적 계획법을 적용하려면 다음 두 가지 조건을 만족해야 한다.

### 1) 최적 부분 구조 (Optimal Substructure)
- 큰 문제의 최적해가 **작은 문제의 최적해로 구성**될 수 있어야 한다.

### 2) 중복 부분 문제 (Overlapping Subproblems)
- 동일한 작은 문제가 **여러 번 반복**해서 등장해야 한다.

---

## 3. DP 접근 방식

### 1) Top-Down (메모이제이션)
- 재귀 + 캐시
- 필요할 때만 계산
- 구현은 직관적이나, 재귀 호출로 인한 스택 오버플로우 위험 존재

```java
int fib(int n) {
 if (n <= 1) return n;
    if (dp[n] != 0) return dp[n];
    return dp[n] = fib(n - 1) + fib(n - 2);
}
```
### 2) Bottom-Up (테이블 방)
- 반복문 기반
- 작은 문제부터 차례대로 해결
```java
dp[0] = 0;
dp[1] = 1;
for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```
---

## 4. DP 문제 풀이 5단계 사고 흐름
1. DP로 풀 수 있는 문제인지 판단
2. DP 배열의 의미 정의
3. 점화식 도출
4. 초기값 설정
5. 계산 순서 설정


---

## 5. 대표적인 DP 유형
### 1) 피보나치 수열
- 가장 기본적인 DP 문제
- 중복 계산 제거의 대표 예시

### 2) 계단 오르기
- 한 번에 1칸 또는 2칸 이동
- 경우의 수 계산 문제
```java
dp[i] = dp[i - 1] + dp[i - 2];
```
### 3) 최대 부분합(Kadane's Algorithm)
- 연속된 부분 배열의 최대 합

```java
dp[i] = Math.max(arr[i], dp[i - 1] + arr[i]);
```

### 4) 배낭 문제(Knapsack)
- 제한된 무게 내에서 최대 가치 선택
- DP 난이도 중급 이상
