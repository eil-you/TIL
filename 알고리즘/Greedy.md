# 그리디 알고리즘 (Greedy Algorithm)

그리디 알고리즘(탐욕법)은 **매 순간 현재 상황에서 최선이라고 생각되는 선택**을 해나가는 방식으로 최종 해답에 도달하는 알고리즘입니다.

## 1. 핵심 개념
- "지금 이 순간 가장 좋은 것을 선택하자."
- 지역적으로 최적인 선택이 결과적으로 전체적인 최적해를 보장할 것이라는 믿음을 바탕으로 합니다.
- 매 선택 시점에서는 **미래를 고려하지 않고 현재의 이득**만을 따집니다.

## 2. 성립 조건
그리디 알고리즘이 최적의 해를 보장하려면 다음 두 가지 조건이 충족되어야 합니다.

1. **탐욕적 선택 속성 (Greedy Choice Property)**
   - 이전의 선택이 이후의 선택에 영향을 주지 않아야 합니다.
2. **최적 부분 구조 (Optimal Substructure)**
   - 문제의 최종 해결 방법이 부분 문제의 최적 해결 방법들로 구성되어야 합니다.

## 3. 알고리즘 수행 과정
1. **선택 절차 (Selection Procedure)**: 현재 상태에서 최적인 해를 선택합니다.
2. **적절성 검사 (Feasibility Check)**: 선택한 해가 문제의 제약 조건을 위반하지 않는지 검사합니다.
3. **해답 검사 (Solution Check)**: 문제가 해결되었는지 검사하고, 해결되지 않았다면 다시 선택 절차로 돌아갑니다.

## 4. 대표적인 예시: 거스름돈 문제
가장 큰 단위의 동전부터 사용하여 동전의 개수를 최소화하는 문제입니다.

### JAVA 코드 예제
```java
public class GreedyExample {
    public static void main(String[] args) {
        int n = 1260; // 거슬러 줘야 할 돈
        int count = 0;

        // 동전 단위 (큰 순서대로)
        int[] coinTypes = {500, 100, 50, 10};

        for (int coin : coinTypes) {
            // 해당 동전으로 거슬러 줄 수 있는 개수만큼 추가
            count += n / coin;
            n %= coin;
        }

        System.out.println("최소 동전 개수: " + count);
    }
}
```

## 5. 장단점
### 장점
- 설계 및 구현이 매우 직관적이고 쉽습니다.
- 계산 중심의 복잡도가 낮아 실행 속도가 빠릅니다.

### 단점
- 항상 최적의 해를 보장하지는 않습니다.
- 따라서 그리디로 접근했을 때 최적해를 얻을 수 있는지에 대한 **정당성 검토**가 매우 중요합니다.

## 6. 주요 문제 유형
- 거스름돈 문제
- 활동 선택 문제 (Activity Selection Problem)
- Huffman Coding (데이터 압축)
- Kruskal, Prim (최소 신장 트리)
- Dijkstra (최단 경로 - 가중치가 양수일 때)
