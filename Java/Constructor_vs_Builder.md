# Constructor vs Builder Pattern

생성자(Constructor)와 빌더 패턴(Builder Pattern)의 차이점은 객체 생성 방식의 **유연성**, **가독성**, 그리고 **안정성**에 있습니다.

## 1. 생성자 (Constructor)
가장 기본적인 객체 생성 방식입니다.

### 특징
*   매개변수가 적을 때 직관적이고 빠릅니다.
*   **단점 (점진적 생성자 패턴)**: 필드가 많아질수록 생성자의 매개변수 개수가 늘어나며, 어떤 값이 어떤 필드에 들어가는지 파악하기 어렵습니다.
*   **타입 오염 위험**: 동일한 타입의 매개변수가 연속되면 순서를 실수해도 컴파일 에러가 나지 않아 런타임 버그를 유발할 수 있습니다.

## 2. 빌더 패턴 (Builder Pattern)
복잡한 객체를 단계별로 생성할 수 있도록 도와주는 디자인 패턴입니다.

### 특징
*   **가독성**: 메서드 명을 통해 각 인자가 어떤 역할을 하는지 명확히 알 수 있습니다.
*   **유연성**: 필요한 데이터만 설정할 수 있으며, 생성 순서에 상관없이 객체를 만들 수 있습니다.
*   **불변성(Immutability)**: 객체 생성 후 수정할 수 없는 '불변 객체'를 만드는 데 유리합니다. (Setter 노출을 최소화할 수 있음)

## 3. 주요 차이점 비교

| 비교 항목 | 생성자 (Constructor) | 빌더 (Builder) |
| :--- | :--- | :--- |
| **가독성** | 매개변수가 많을수록 낮아짐 | 메서드 명시로 매우 높음 |
| **안정성** | 인자 순서 변경 시 오류 가능성 있음 | 각 메서드가 필드를 지정하므로 안전함 |
| **유연성** | 필요한 조합마다 오버로딩 필요 | 가변적인 인자 처리가 자유로움 |
| **불변성** | 구현 가능하지만 번거로움 | 불변 객체 생성에 최적화됨 |
| **복잡도** | 단순하고 추가 코드 없음 | 별도의 빌더 클래스 구현 필요 (Lombok으로 해결 가능) |

## 4. 코드 예시 (Java)

### 생성자 방식
```java
// 순서를 실수하기 쉬움 (age와 height가 바뀌어도 컴파일러는 모름)
User user = new User("홍길동", 20, 180, "서울");
```

### 빌더 방식
```java
// 각 값이 무엇을 의미하는지 명확함
User user = User.builder()
                .name("홍길동")
                .age(20)
                .height(180)
                .address("서울")
                .build();
```

---

## 5. Lombok @Builder의 작동 원리

Lombok의 `@Builder`는 컴파일 시점에 자바의 **AST(Abstract Syntax Tree, 추상 구문 트리)**를 직접 조작하여 실제 빌더 패턴 코드를 생성해 넣는 방식으로 동작합니다.

### (1) 어노테이션 프로세싱 (Annotation Processing)
1.  **컴파일 시점 개입**: 자바 컴파일러(`javac`)가 소스 코드를 읽어 구문 분석을 할 때 Lombok이 개입합니다.
2.  **코드 주입**: 메모리상의 AST를 수정하여 `UserBuilder`라는 정적 내부 클래스와 관련 메서드들을 주입합니다.
3.  **바이트코드 생성**: 최종적인 `.class` 파일에는 우리가 작성하지 않은 빌더 코드가 모두 포함됩니다.

### (2) 생성되는 내부 코드 구조
클래스 레벨에 `@Builder`를 붙이면 다음과 같은 구조가 자동으로 만들어집니다.
*   **정적 내부 클래스**: 원본 필드를 복사한 `UserBuilder` 클래스 생성
*   **설정 메서드**: 각 필드에 대해 필드명과 동일한 이름의 메서드 생성 (`return this;`를 통한 메서드 체이닝 제공)
*   **build() 메서드**: 내부 빌더 클래스에 생성되며, 모아진 값으로 원본 클래스의 생성자를 호출하여 객체 반환
*   **전체 생성자**: `@Builder`는 객체 생성을 위해 **모든 필드를 인자로 받는 생성자**가 반드시 필요합니다. 클래스에 생성자가 없다면 Lombok이 자동으로 `AllArgsConstructor`를 패키지 권한으로 생성합니다.

### (3) 주의사항
*   클래스에 이미 다른 생성자가 있는 경우, `@Builder`만 사용하면 오류가 날 수 있습니다. 이 경우 `@AllArgsConstructor`를 함께 붙여주거나 모든 필드를 포함하는 생성자를 직접 작성해야 합니다.

---

## 6. 예상 면접 질문 (Q&A)

**Q1. 자바에서 생성자 대신 빌더 패턴을 사용하는 가장 큰 이유는 무엇인가요?**
*   **A.** 가장 큰 이유는 **가독성과 안정성**입니다. 필드가 많아질수록 생성자는 인자의 순서를 기억하기 어렵고 실수할 가능성이 높지만, 빌더는 세터 메서드와 유사한 형식을 통해 어떤 데이터를 입력하는지 명확히 보여줍니다. 또한, 불변 객체를 만들기 쉽다는 장점도 있습니다.

**Q2. 빌더 패턴의 단점은 무엇인가요?**
*   **A.** 객체를 만들기 위해 빌더라는 별도의 클래스를 만들어야 하므로 코드 양이 늘어나고 설계가 복잡해질 수 있습니다. 또한, 매 성능이 매우 민감한 상황에서는 빌더 객체를 거쳐서 생성하는 과정이 미세한 오버헤드가 될 수 있습니다. 하지만 최근에는 Lombok의 `@Builder` 어노테이션을 통해 코드 복잡성 문제를 대부분 해결합니다.

**Q3. 생성자 오버로딩과 빌더 패턴 중 언제 무엇을 선택해야 할까요?**
*   **A.** 매개변수가 3~4개 이하로 적고 필수 필드 위주라면 생성자를 사용하는 것이 더 빠르고 간결할 수 있습니다. 하지만 매개변수가 그보다 많거나, 선택적으로 입력해야 하는 필드가 다양하다면 빌더 패턴을 사용하는 것이 유지보수 측면에서 훨씬 유리합니다.

**Q4. 빌더 패턴에서 필수 인자를 어떻게 강제할 수 있나요?**
*   **A.** 빌더 생성자나 별도의 static 메서드에서 필수 값을 인자로 받도록 설계하거나, `build()` 메서드 호출 시 필수 값의 null 체크 로직을 넣어 검증할 수 있습니다.
