# 기본 데이터 타입 (Primitive Type) vs 참조 데이터 타입 (Reference Type)

자바의 데이터 타입은 크게 **기본 타입(Primitive Type)**과 **참조 타입(Reference Type)**으로 나뉩니다. 이 둘의 가장 큰 차이점은 **값이 저장되는 방식**과 **메모리 위치**에 있습니다.

---

## 1. 한눈에 비교하기

| 구분 | 기본 타입 (Primitive Type) | 참조 타입 (Reference Type) |
| :--- | :--- | :--- |
| **종류** | 정수, 실수, 문자, 논리 리터럴 | 클래스, 인터페이스, 배열, 열거형 |
| **저장 값** | 실제 데이터 값 | 메모리 상의 객체 주소 (참조값) |
| **저장 위치** | **스택(Stack)** 영역 | 실제 객체는 **힙(Heap)**, 주소는 **스택(Stack)** |
| **기본값** | 데이터 타입에 따라 다름 (0, false 등) | `null` |
| **메모리 사용** | 컴파일 시점에 크기가 결정되어 고정됨 | 런타임에 동적으로 할당됨 |

---

## 2. 기본 데이터 타입 (Primitive Type)

자바에서는 총 8가지의 기본 타입을 제공합니다. 비객체 타입이며, 산술 연산이 가능합니다.

- **정수형**: `byte` (1), `short` (2), `int` (4), `long` (8)
- **실수형**: `float` (4), `double` (8)
- **문자형**: `char` (2, Unicode)
- **논리형**: `boolean` (1)

### 특징
- 실제 값을 변수 안에 직접 저장합니다.
- 메모리 사용이 효율적이고 접근 속도가 빠릅니다.
- `null`을 담을 수 없습니다. (필요 시 Wrapper 클래스 사용)

---

## 3. 참조 데이터 타입 (Reference Type)

기본 타입을 제외한 모든 타입(객체)을 말합니다.

- **클래스 (Class)**: String, 사용자 정의 클래스 등
- **인터페이스 (Interface)**
- **배열 (Array)**
- **열거형 (Enum)**

### 특징
- 변수에는 객체가 생성된 **메모리 번지(주소)**가 저장됩니다.
- 실제 객체는 **Heap** 영역에 생성되며, 변수는 이를 가리킵니다.
- `null`을 가질 수 있으며, 주소가 없는 상태에서 메서드를 호출하면 `NullPointerException`이 발생합니다.

---

## 4. 메모리 구조에서의 차이 (Stack vs Heap)

### 기본 타입
```java
int age = 25;
```
- `age`라는 변수가 스택 영역에 생성되고, 그 안에 `25`라는 값이 직접 들어갑니다.

### 참조 타입
```java
String name = "Yubin";
```
1. **Heap 영역**: 실제 "Yubin"이라는 문자열 객체가 생성됩니다. (예: 주소값 `0x100`)
2. **Stack 영역**: `name` 변수가 생성되고, 값으로 `0x100`이 저장됩니다.

---

## 5. 주요 문답 (Q&A)

### Q. 왜 String은 참조 타입인데 기본 타입처럼 쓰나요?
A. `String`은 자바에서 매우 자주 쓰이기 때문에 리터럴 방식(`"..."`)으로 생성할 수 있도록 특별 대우를 해줍니다. 내부적으로는 `String Constant Pool`을 사용하여 메모리를 관리하는 참조 타입입니다.

### Q. 기본 타입을 객체로 쓰고 싶을 땐 어떻게 하나요?
A. **Wrapper 클래스**를 사용합니다. (예: `int` → `Integer`, `double` → `Double`) 이를 통해 컬렉션(`List`, `Map` 등)에 기본 타입을 담거나 `null`을 허용할 수 있습니다. (Auto-boxing / Unboxing 지원)

---

## 6. int vs Integer (기본 타입 vs Wrapper 클래스)

가장 많이 혼동하는 `int`와 `Integer`의 차이를 좀 더 깊게 살펴보겠습니다.

| 구분 | int (Primitive Type) | Integer (Wrapper Class) |
| :--- | :--- | :--- |
| **타입** | 기본 데이터 타입 | 참조 데이터 타입 (객체) |
| **메모리** | **Stack**에 실제 값 저장 | **Heap**에 객체 저장, **Stack**엔 주소 저장 |
| **null 허용** | **불가능** (최소 0이라도 가짐) | **가능** (`null` 저장 가능) |
| **제네릭 사용** | **불가능** (`List<int>` X) | **가능** (`List<Integer>` O) |
| **메서드 활용** | 불가능 | 가능 (예: `Integer.parseInt()`) |

### 핵심 차이: Boxing & Unboxing
자바는 이 두 타입을 서로 넘나들 수 있도록 **Autoboxing**과 **Autounboxing**을 지원합니다.

- **Boxing**: `int` -> `Integer` (기본 타입을 객체로 감쌈)
- **Unboxing**: `Integer` -> `int` (객체에서 값을 꺼냄)

```java
Integer num = 10;           // Autoboxing
int n = num;                // Autounboxing
```

### 언제 무엇을 써야 할까?
1. **성능이 중요하다면? `int`**
   - 산술 연산이 잦거나 대량의 데이터를 처리할 때는 메모리 오버헤드가 없는 `int`가 훨씬 빠릅니다.
2. **`null`값이 필요하다면? `Integer`**
   - DB에서 값을 가져올 때 `null` 상태를 표현해야 하거나, 비어있는 값을 처리해야 할 때는 `Integer`를 씁니다.
3. **제네릭이나 컬렉션을 쓴다면? `Integer`**
   - `ArrayList`, `HashMap` 등 자바 컬렉션은 기본 타입을 담을 수 없으므로 반드시 `Integer`를 사용해야 합니다.

---

## 7. 보충 설명: 제네릭 (Generic)

앞서 `Integer`를 설명할 때 언급된 **제네릭(Generic)**에 대한 상세 내용은 별도의 문서로 정리하였습니다.

- **[제네릭(Generics) 상세 보기](./Generics.md)**
- **[메모리 누수(Memory Leak)와 해결책](./Memory%20Leak.md)**

간단히 요약하자면, 제네릭은 **타입을 파라미터처럼 다루는 기법**이며, 자바 설계 구조상 객체(`Object`)를 다뤄야 하기 때문에 기본 타입인 `int` 대신 참조 타입인 `Integer`를 사용해야 합니다.

---

## 8. 참조 타입의 변경과 Heap 메모리 동작

"데이터가 바뀌면 Heap에 새 데이터가 생기나요, 아니면 기존 데이터가 바뀌나요?"라는 질문은 자바 메모리 관리의 핵심입니다. 결론부터 말씀드리면 **"그 객체가 가변(Mutable) 인지 불변(Immutable) 인지"**에 따라 달라집니다.

### 1) 불변 객체 (Immutable Object) - 예: String, Integer
이 타입들은 한 번 Heap에 생성되면 그 내부의 값을 절대 바꿀 수 없습니다.

```java
String name = "Yubin"; // Heap 주소 0x100에 "Yubin" 생성
name = "Antigravity";  // Heap 주소 0x200에 "Antigravity" 새로 생성!
```
- **동작**: 기존 `0x100`의 데이터를 수정하는 것이 아니라, 아예 **새로운 공간(`0x200`)을 잡고 새 데이터**를 넣습니다.
- **결과**: `name` 변수(Stack)는 이제 `0x200`을 가리킵니다. 기존 `0x100`에 있던 "Yubin"은 아무도 찾지 않게 되어 나중에 **Garbage Collector(GC)**가 수거해갑니다.

### 2) 가변 객체 (Mutable Object) - 예: 일반 클래스, StringBuilder
우리가 직접 만든 클래스나 값을 바꿀 수 있게 설계된 객체들입니다.

```java
User user = new User("Yubin"); // Heap 주소 0x500에 객체 생성
user.setName("Antigravity");    // 주소는 그대로 0x500, 내부 데이터만 변경!
```
- **동작**: Stack에 저장된 주소값(`0x500`)은 변하지 않습니다. **Heap에 있는 그 메모리 주소로 찾아가서 내부의 값만 쏙 바꿉니다.**
- **결과**: 새로운 메모리 점유 없이 효율적으로 데이터를 수정합니다.

### 💡 요약
- **재할당(`= new ...`)**을 하면 무조건 Heap에 **새로운** 자리가 생깁니다.
- **불변 객체(`String` 등)**의 값을 바꾸려 하면 무조건 Heap에 **새로운** 자리가 생깁니다.
- **가변 객체**의 필드 값을 수정하면 **기존** 자리를 그대로 사용합니다.

---

## 9. 메모리 할당 방식에 따른 장단점

기본 타입과 참조 타입은 메모리가 잡히는 위치(Stack vs Heap)가 다르기 때문에 확연한 장단점을 가집니다.

### 1) 기본 데이터 타입 (Primitive Type)
> **Stack**에 값 자체가 바로 저장됨

- **장점**:
  - **속도가 매우 빠름**: 포인터를 따라갈 필요 없이 메모리에서 바로 값을 읽어오기 때문에 연산 성능이 뛰어납니다.
  - **메모리 효율적**: 데이터 크기가 정해져 있고 객체 헤더와 같은 추가 메타데이터가 붙지 않아 공간을 적게 차지합니다.
  - **메모리 관리 자동화**: 메서드가 끝나고 스택 프레임이 날아갈 때 즉시 제거되므로 별도의 GC 부하가 없습니다.
- **단점**:
  - **유연성 부족**: 상속을 받거나 메서드를 정의할 수 없습니다.
  - **null 불가**: "값이 없음"이라는 상태를 정의하기 어렵습니다. (0이나 -1 등으로 우회해야 함)

### 2) 참조 데이터 타입 (Reference Type)
> **Heap**에 실제 데이터가, **Stack**에 주소값이 저장됨

- **장점**:
  - **다양한 표현력**: 복잡한 데이터 구조를 만들 수 있고, 상속과 다형성을 활용한 객체 지향 프로그래밍이 가능합니다.
  - **null 표현 가능**: 객체가 할당되지 않았음을 `null`로 명확히 표현할 수 있습니다.
  - **동적 크기 할당**: 런타임에 데이터의 크기가 변해도 Heap 영역을 통해 유연하게 대응할 수 있습니다.
- **단점**:
  - **속도 저하 (Dereferencing)**: Stack에서 주소값을 먼저 찾고, 그 주소를 따라 Heap으로 이동해야 하므로 기본 타입보다 접근 속도가 느립니다.
  - **메모리 오버헤드**: 실제 데이터 외에도 객체의 정보(헤더, 포인터 등)를 저장하기 위한 추가 공간이 필요합니다.
  - **GC 부하**: 힙 영역에 쌓인 객체들은 수시로 Garbage Collector가 확인하고 수거해야 하므로 CPU 자원을 소모합니다.

---

### 요약
> **값 그 자체**를 다루고 싶고 성능이 중요하다면 **기본 타입(`int`)**을,
> **객체 지향적인 기능(메서드, 상속 등)**이나 **`null` 표현**, **제네릭/컬렉션 활용**이 필요하다면 **참조 타입(`Integer`)**을 사용합니다.
