# 기본 데이터 타입 (Primitive Type) vs 참조 데이터 타입 (Reference Type)

자바의 데이터 타입은 크게 **기본 타입(Primitive Type)**과 **참조 타입(Reference Type)**으로 나뉩니다. 이 둘의 가장 큰 차이점은 **값이 저장되는 방식**과 **메모리 위치**에 있습니다.

---

## 1. 한눈에 비교하기

| 구분 | 기본 타입 (Primitive Type) | 참조 타입 (Reference Type) |
| :--- | :--- | :--- |
| **종류** | 정수, 실수, 문자, 논리 리터럴 | 클래스, 인터페이스, 배열, 열거형 |
| **저장 값** | 실제 데이터 값 | 메모리 상의 객체 주소 (참조값) |
| **저장 위치** | **스택(Stack)** 영역 | 실제 객체는 **힙(Heap)**, 주소는 **스택(Stack)** |
| **기본값** | 데이터 타입에 따라 다름 (0, false 등) | `null` |
| **메모리 사용** | 컴파일 시점에 크기가 결정되어 고정됨 | 런타임에 동적으로 할당됨 |

---

## 2. 기본 데이터 타입 (Primitive Type)

자바에서는 총 8가지의 기본 타입을 제공합니다. 비객체 타입이며, 산술 연산이 가능합니다.

- **정수형**: `byte` (1), `short` (2), `int` (4), `long` (8)
- **실수형**: `float` (4), `double` (8)
- **문자형**: `char` (2, Unicode)
- **논리형**: `boolean` (1)

### 특징
- 실제 값을 변수 안에 직접 저장합니다.
- 메모리 사용이 효율적이고 접근 속도가 빠릅니다.
- `null`을 담을 수 없습니다. (필요 시 Wrapper 클래스 사용)

---

## 3. 참조 데이터 타입 (Reference Type)

기본 타입을 제외한 모든 타입(객체)을 말합니다.

- **클래스 (Class)**: String, 사용자 정의 클래스 등
- **인터페이스 (Interface)**
- **배열 (Array)**
- **열거형 (Enum)**

### 특징
- 변수에는 객체가 생성된 **메모리 번지(주소)**가 저장됩니다.
- 실제 객체는 **Heap** 영역에 생성되며, 변수는 이를 가리킵니다.
- `null`을 가질 수 있으며, 주소가 없는 상태에서 메서드를 호출하면 `NullPointerException`이 발생합니다.

---

## 4. 메모리 구조에서의 차이 (Stack vs Heap)

### 기본 타입
```java
int age = 25;
```
- `age`라는 변수가 스택 영역에 생성되고, 그 안에 `25`라는 값이 직접 들어갑니다.

### 참조 타입
```java
String name = "Yubin";
```
1. **Heap 영역**: 실제 "Yubin"이라는 문자열 객체가 생성됩니다. (예: 주소값 `0x100`)
2. **Stack 영역**: `name` 변수가 생성되고, 값으로 `0x100`이 저장됩니다.

---

## 5. 주요 문답 (Q&A)

### Q. 왜 String은 참조 타입인데 기본 타입처럼 쓰나요?
A. `String`은 자바에서 매우 자주 쓰이기 때문에 리터럴 방식(`"..."`)으로 생성할 수 있도록 특별 대우를 해줍니다. 내부적으로는 `String Constant Pool`을 사용하여 메모리를 관리하는 참조 타입입니다.

### Q. 기본 타입을 객체로 쓰고 싶을 땐 어떻게 하나요?
A. **Wrapper 클래스**를 사용합니다. (예: `int` → `Integer`, `double` → `Double`) 이를 통해 컬렉션(`List`, `Map` 등)에 기본 타입을 담거나 `null`을 허용할 수 있습니다. (Auto-boxing / Unboxing 지원)

---

## 6. int vs Integer (기본 타입 vs Wrapper 클래스)

가장 많이 혼동하는 `int`와 `Integer`의 차이를 좀 더 깊게 살펴보겠습니다.

| 구분 | int (Primitive Type) | Integer (Wrapper Class) |
| :--- | :--- | :--- |
| **타입** | 기본 데이터 타입 | 참조 데이터 타입 (객체) |
| **메모리** | **Stack**에 실제 값 저장 | **Heap**에 객체 저장, **Stack**엔 주소 저장 |
| **null 허용** | **불가능** (최소 0이라도 가짐) | **가능** (`null` 저장 가능) |
| **제네릭 사용** | **불가능** (`List<int>` X) | **가능** (`List<Integer>` O) |
| **메서드 활용** | 불가능 | 가능 (예: `Integer.parseInt()`) |

### 핵심 차이: Boxing & Unboxing
자바는 이 두 타입을 서로 넘나들 수 있도록 **Autoboxing**과 **Autounboxing**을 지원합니다.

- **Boxing**: `int` -> `Integer` (기본 타입을 객체로 감쌈)
- **Unboxing**: `Integer` -> `int` (객체에서 값을 꺼냄)

```java
Integer num = 10;           // Autoboxing
int n = num;                // Autounboxing
```

### 언제 무엇을 써야 할까?
1. **성능이 중요하다면? `int`**
   - 산술 연산이 잦거나 대량의 데이터를 처리할 때는 메모리 오버헤드가 없는 `int`가 훨씬 빠릅니다.
2. **`null`값이 필요하다면? `Integer`**
   - DB에서 값을 가져올 때 `null` 상태를 표현해야 하거나, 비어있는 값을 처리해야 할 때는 `Integer`를 씁니다.
3. **제네릭이나 컬렉션을 쓴다면? `Integer`**
   - `ArrayList`, `HashMap` 등 자바 컬렉션은 기본 타입을 담을 수 없으므로 반드시 `Integer`를 사용해야 합니다.

---

## 7. 보충 설명: 제네릭 (Generic) 이란?

앞서 `Integer`를 설명할 때 "제네릭에 사용 가능"하다고 언급했습니다. 제네릭이 무엇인지 간단히 알아봅시다.

**제네릭(Generic)**은 **"데이터의 타입을 내부에서 확정하지 않고, 외부에서 지정하는 기법"**입니다. 쉽게 말해 타입을 파라미터(변수)처럼 다루는 것입니다.

- **표현**: 클래스나 메서드 뒤에 `<T>` (Type)와 같이 화살표 괄호를 붙여 사용합니다.
- **예시**: `ArrayList<Integer> list = new ArrayList<>();`
  - "이 리스트 안에는 오직 `Integer` 타입만 들어갈 수 있어!"라고 타입을 강제하는 것입니다.

### 왜 제네릭에는 참조 타입만 써야 할까?
자바의 제네릭은 설계상 **객체(Object)**를 다루도록 만들어졌습니다. `int`와 같은 기본 타입은 `Object`의 후손이 아니기 때문에 제네릭 파라미터로 넘길 수 없습니다. 그래서 `List<int>` 대신 `List<Integer>`를 사용하는 것입니다. (내부적으로 자바가 Autoboxing을 통해 `int`를 `Integer`로 바꿔서 넣어줍니다.)

---

### 요약
> **값 그 자체**를 다루고 싶고 성능이 중요하다면 **기본 타입(`int`)**을,
> **객체 지향적인 기능(메서드, 상속 등)**이나 **`null` 표현**, **제네릭/컬렉션 활용**이 필요하다면 **참조 타입(`Integer`)**을 사용합니다.
