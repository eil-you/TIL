# HashMap vs TreeMap 상세 비교

Java의 `Map` 인터페이스를 구현하는 대표적인 두 클래스인 `HashMap`과 `TreeMap`의 주요 차이점입니다.

---

## 1. 비교 요약표

| 항목 | HashMap | TreeMap |
| :--- | :--- | :--- |
| **자료구조** | 해시 테이블 (Hash Table) | 레드-블랙 트리 (Red-Black Tree) |
| **정렬 여부** | **정렬되지 않음** (순서 보장 X) | **키(Key) 기준 오름차순 정렬** |
| **시간 복잡도** | **O(1)** (평균 탐색 속도) | **O(log N)** (항상 보장) |
| **null 허용** | 키(Key)에 null 허용 (1개만) | **키(Key)에 null 허용 안 함** |
| **사용 시점** | 빠른 검색이 최우선일 때 | 데이터 정렬이 필요할 때 |

---

## 2. HashMap의 특징
- **동작 방식**: 키의 `hashCode()`를 이용해 배열 인덱스를 계산하여 저장합니다.
- **순서**: 데이터가 삽입된 순서나 키의 크기 순서와 관계없이 내부 해시 함수에 의해 결정된 위치에 저장되므로, 출력 시 순서가 계속 바뀔 수 있습니다. (순서 보장이 필요하면 `LinkedHashMap` 사용)
- **성능**: 해시 충돌이 적다는 가정하에 삽입, 삭제, 검색 모두 $O(1)$로 매우 빠릅니다.

---

## 3. TreeMap의 특징
- **동작 방식**: 이진 탐색 트리의 일종인 **레드-블랙 트리(Red-Black Tree)** 구조를 사용합니다.
- **순서**: 내부적으로 정렬되어 저장됩니다. 기본적으로 키의 자연 순서(Numerical, Alphabetical)를 따르며, 별도의 `Comparator`를 지정할 수도 있습니다.
- **성능**: 모든 작업이 $O(\log N)$의 성능을 가집니다. 데이터 양이 많아져도 성능 저하가 비교적 일정합니다.
- **추가 기능**: 정렬된 상태를 활용한 `firstKey()`, `lastKey()`, `subMap()` 등 범위 검색이나 최댓값/최솟값과 관련된 유용한 메서드를 제공합니다.

---

## 4. 선택 기준 가이드
1. **일반적인 경우**: 대부분의 검색 작업에는 성능이 가장 빠른 **`HashMap`**을 사용합니다.
2. **정렬이 필요한 경우**: 데이터를 키 순서대로 순회해야 하거나, 특정 범위의 데이터를 추출해야 한다면 **`TreeMap`**을 선택합니다.
3. **순서 유지가 필요한 경우**: 삽입한 순서 그대로 유지하면서 $O(1)$ 성능을 내고 싶다면 **`LinkedHashMap`**을 고려합니다.
