# List vs Set 상세 비교

Java의 Collection 인터페이스를 상속받는 대표적인 두 인터페이스인 `List`와 `Set`의 주요 차이점입니다.

---

## 1. 비교 요약표

| 항목 | List (ArrayList, LinkedList) | Set (HashSet, TreeSet) |
| :--- | :--- | :--- |
| **중복 허용** | **허용함** | **허용하지 않음** (고유 원소만 저장) |
| **순서 보장** | **삽입 순서 유지** | **기본적으로 보장하지 않음** (하위 클래스에 따라 다름) |
| **인덱스 접근** | **가능** (`get(index)`) | **불가능** (반복자나 stream 사용) |
| **null 허용** | 여러 개 허용 | 최대 1개만 허용 (TreeSet은 null 불가) |
| **주요 구현체** | ArrayList, LinkedList, Vector | HashSet, LinkedHashSet, TreeSet |

---

## 2. List의 특징
- **동작 방식**: 데이터를 순차적으로 관리하며, 각 데이터는 **인덱스(Index)**라는 위치 값을 가집니다.
- **순서**: 데이터가 들어온 순서를 엄격하게 유지합니다.
- **성능**: 
    - **ArrayList**: 인덱스를 통한 조회($O(1)$)가 매우 빠르지만, 중간에 데이터를 삽입/삭제할 경우 데이터를 밀거나 당기는 과정($O(N)$)이 필요합니다.
    - **LinkedList**: 노드 간의 연결을 통해 관리되므로 삽입/삭제($O(1)$ - 위치를 알 때)는 빠르지만, 특정 인덱스를 찾기 위해 순회($O(N)$)해야 합니다.
- **사용 시점**: 데이터의 중복이 발생할 수 있거나, 저장된 순서가 중요할 때, 혹은 특정 위치의 데이터에 빠르게 접근해야 할 때 사용합니다.

---

## 3. Set의 특징
- **동작 방식**: 수학의 '집합' 개념을 구현한 것으로, 중복된 데이터를 저장할 수 없습니다. 
- **순서**:
    - **HashSet**: 순서를 전혀 보장하지 않습니다. 해시 함수에 의해 위치가 결정됩니다.
    - **LinkedHashSet**: 삽입된 순서를 유지합니다.
    - **TreeSet**: 데이터의 값에 따라 자동으로 정렬(오름차순 등)됩니다.
- **성능**: 
    - **HashSet**: 해시 테이블을 사용하므로 삽입, 삭제, 검색 성능이 평균 **$O(1)$**로 매우 빠릅니다.
    - **TreeSet**: 레드-블랙 트리를 사용하여 모든 작업에서 **$O(\log N)$**의 성능을 보장합니다.
- **사용 시점**: 데이터의 고유성(Uniqueness)이 보장되어야 할 때(예: 사용자 ID 목록, 당첨 번호 등), 또는 특정 데이터의 존재 여부를 빠르게 확인해야 할 때 사용합니다.

---

## 4. 선택 기준 가이드
1. **중복이 있어도 되는가?**: 그렇다면 **`List`**를 선택하세요.
2. **중복을 절대 허용하지 않아야 하는가?**: 그렇다면 **`Set`**을 선택하세요.
3. **인덱스로 접근해야 하는가?**: 그렇다면 **`List`**가 필수입니다.
4. **검색 성능이 가장 중요한가?**: 데이터가 있는지 없는지 확인하는 작업이 많다면 **`HashSet`**이 가장 유리합니다.
5. **데이터가 정렬되어 있어야 하는가?**: **`TreeSet`**을 고려하거나, **`List`**를 사용한 후 `Collections.sort()`를 활용하세요.

---

## 5. [Deep Dive] HashSet의 검색이 O(1)인 이유?

`List`는 특정 데이터를 찾으려면 처음부터 끝까지 다 뒤져봐야 하지만($O(N)$), `HashSet`은 데이터를 번호표(해시값)로 관리하기 때문에 "한 번에" 찾아낼 수 있습니다.

### 1) 해싱 (Hashing) 원리
1. **주소 계산**: 찾으려는 객체의 `hashCode()`를 호출하여 고유한 정수값을 얻습니다.
2. **인덱스 변환**: 이 해시값을 내부 저장소(Bucket)의 크기에 맞춰 인덱스로 변환합니다. (예: `index = hash % bucket_size`)
3. **직접 접근**: 계산된 인덱스로 곧장 달려가서 데이터가 있는지 확인합니다. 마치 아파트 호수(인덱스)를 알고 벨을 누르는 것과 같습니다.

### 2) hashCode()와 equals()의 역할
- **`hashCode()`**: "어느 방(Bucket)에 들어갈지"를 결정합니다. 같은 방이면 해시값이 같습니다.
- **`equals()`**: 만약 같은 방에 여러 데이터가 있다면(해시 충돌), 그 방 안에서 "진짜 내가 찾는 데이터가 맞는지" 하나씩 비교할 때 사용합니다.

### 3) 성능 요약
- **평균 $O(1)$**: 대부분의 경우 해시 함수가 데이터를 골고루 배분하므로 바로 찾을 수 있습니다.
- **최악 $O(N)$**: 모든 데이터의 해시값이 같아서 한 방에 몰리는 '해시 충돌'이 발생하면 성능이 떨어질 수 있습니다. (하지만 Java 8부터는 충돌이 많아지면 내부적으로 트리 구조를 사용하여 성능을 $O(\log N)$으로 방어합니다.)

> **결론**: `HashSet`의 `contains()`가 빠른 이유는 데이터를 순차적으로 비교하지 않고, **값 자체를 주소로 바꿔서 직접 접근**하기 때문입니다.

---

## 6. [Performance Tip] HashSet 초기 용량 설정하기

HashSet을 생성할 때 담을 데이터의 개수를 안다면, 초기 용량(Initial Capacity)을 지정해주는 것이 성능상 유리합니다.

### 1) 왜 하는가?
Java의 HashSet은 내부 공간이 약 75%(Load Factor 0.75) 차면, 공간을 2배로 늘리는 **리사이징(Resizing)**을 수행합니다. 이때 기존 데이터를 모두 새 공간으로 옮기는 부담(Rehashing)이 발생하는데, 이를 미리 방지하기 위함입니다.

### 2) 계산 방법
내가 담을 데이터의 개수가 $N$개라면:
- **공식**: `(N / 0.75) + 1` 이상의 값을 생성자에 전달

**예시: 5개를 담을 경우**
1. $5 \div 0.75 + 1 \approx 7.66$
2. `new HashSet<>(8)` 또는 넉넉하게 `new HashSet<>(10)` 선택
3. 내부적으로 용량이 8(2의 거듭제곱)이 되면, 임계점은 $8 \times 0.75 = 6$이 되어 5개를 담는 동안 리사이징이 발생하지 않습니다.

