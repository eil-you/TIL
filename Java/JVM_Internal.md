# JVM (Java Virtual Machine) 작동 원리

JVM은 자바 애플리케이션을 실행하는 가상 컴퓨터입니다. "Write Once, Run Anywhere (WORA)"를 가능하게 하며, 플랫폼에 독립적으로 자바 프로그램을 실행할 수 있게 해줍니다.

## 1. JVM 전체 구조
JVM은 크게 세 가지 서브시스템으로 구성됩니다.
1. **클래스 로더 시스템 (Class Loader Subsystem)**
2. **런타임 데이터 영역 (Runtime Data Areas - Memory)**
3. **실행 엔진 (Execution Engine)**

---

## 2. 클래스 로더 시스템 (Class Loader Subsystem)
`.class` 바이트코드를 읽어서 메모리에 적재하는 역할을 하며, 3단계로 동작합니다.

1. **Loading (로딩)**: 클래스 파일을 읽어 JVM 메모리에 올립니다. (Bootstrap, Extension, Application 클래스 로더)
2. **Linking (링크)**: 파일을 검증하고 준비합니다.
    - **Verify**: 바이트코드가 유효한지 확인합니다.
    - **Prepare**: 클래스 변수(static)를 위한 메모리를 할당하고 기본값을 채웁니다.
    - **Resolve**: 심볼릭 레퍼런스를 실제 메모리 주소(Direct Reference)로 바꿉니다.
3. **Initialization (초기화)**: static 변수들을 코드에 명시된 값으로 초기화합니다.

---

## 3. 런타임 데이터 영역 (Runtime Data Areas)
JVM이 프로그램을 실행하면서 사용하는 공유 메모리 영역입니다.

*   **PC Register**: 현재 실행 중인 스레드의 Instruction 주소를 가집니다. (스레드별 생성)
*   **JVM Stack**: 메서드 호출 시 생성되는 프레임이 저장됩니다. 지역 변수, 파라미터 등이 담깁니다. (스레드별 생성)
*   **Native Method Stack**: 자바가 아닌 C/C++ 코드를 실행하기 위한 공간입니다. (스레드별 생성)
*   **Method Area**: 클래스 수준의 정보(클래스 이름, 부모 이름, 메서드 정보, static 변수)를 저장합니다. (**모든 스레드 공유**)
*   **Heap Area**: `new` 연산자로 생성된 모든 객체와 배열이 저장됩니다. (**모든 스레드 공유**, GC의 대상)

---

## 4. 실행 엔진 (Execution Engine)
메모리에 적재된 바이트코드를 실행하는 주체입니다.

1. **Interpreter (인터프리터)**: 바이트코드를 한 줄씩 읽어서 기계어로 번역하고 실행합니다. 반복되는 코드의 경우 속도가 느린 단점이 있습니다.
2. **JIT Compiler (Just-In-Time Compiler)**: 인터프리터의 단점을 보완합니다. 반복되는 코드를 찾아 한꺼번에 기계어로 컴파일하여 캐시에 저장해 두었다가, 이후에는 컴파일된 코드를 바로 실행합니다.
3. **Garbage Collector (GC)**: Heap 영역에서 더 이상 참조되지 않는 객체들을 찾아 메모리를 해제합니다.

---

## 5. 예상 면접 질문 (Q&A)

**Q1. 자바의 "플랫폼 독립성"은 무엇을 의미하나요?**
*   **A.** 자바 컴파일러는 소스 코드를 특정 CPU용 기계어가 아닌 **바이트코드(.class)**로 변미합니다. 이 바이트코드는 OS에 상관없이 해당 OS용 JVM만 설치되어 있다면 어디서든 동일하게 실행될 수 있습니다.

**Q2. JIT 컴파일러란 무엇인가요?**
*   **A.** 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하는 방식입니다. 이를 통해 반복되는 코드에 대해 실행 속도를 획기적으로 높일 수 있습니다.

**Q3. Stack과 Heap의 차이점을 설명해 주세요.**
*   **A.** **Stack**은 스레드마다 독립적으로 존재하며 메서드 호출이 끝나면 사라지는 지역 변수나 기본 타입 변수가 저장됩니다. **Heap**은 모든 스레드가 공유하며, `new` 키워드로 생성된 객체가 저장되고 개발자가 직접 해제하지 않아도 GC에 의해 관리됩니다.

**Q4. 클래스 변수(static)는 어디에 저장되나요?**
*   **A.** Java 8 이전에는 PermGen 영역에, Java 8 이후에는 **Method Area (또는 Metaspace)** 에 저장되어 모든 스레드가 공유합니다.
