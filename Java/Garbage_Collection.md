# 가비지 컬렉션 (Garbage Collection, GC)

가비지 컬렉션은 자바 가상 머신(JVM)이 **더 이상 사용되지 않는 객체를 자동으로 메모리에서 해제**하는 프로세스입니다. 개발자가 직접 메모리를 해제할 필요가 없어 메모리 누수 방지에 큰 도움이 됩니다.

---

## 1. GC의 대상: Reachability
JVM은 객체에 참조가 남아있는지를 기준으로 가비지 대상을 판단합니다.
- **Reachable**: 유효한 참조가 있는 상태.
- **Unreachable**: 어떤 참조도 없어 더 이상 사용되지 않는 상태 (-> **GC 대상**)

---

## 2. Heap 메모리 구조와 GC
JVM의 힙(Heap) 영역은 객체의 생존 기간에 따라 크게 두 영역으로 나뉩니다.

### Young Generation
새로 생성된 객체들이 위치하는 영역입니다.
- **Eden**: 객체가 처음 생성되는 곳.
- **Survivor 0 / Survivor 1**: 최소 1번 이상의 GC에서 살아남은 객체가 이동하는 곳.
- **Minor GC**: Young 영역에서 발생하는 GC. 속도가 매우 빠릅니다.

### Old Generation
Young 영역에서 오랫동안 살아남은 객체들이 이동하는 영역입니다.
- **Major GC (Full GC)**: Old 영역에서 발생하는 GC. Young 영역보다 크기가 크기 때문에 속도가 느립니다.

---

## 3. GC 알고리즘: Mark and Sweep
대부분의 GC는 크게 3단계로 동작합니다.

1. **Mark**: 사용되고 있는 객체(Reachable)를 식별하여 표시합니다.
2. **Sweep**: 표시되지 않은(Unreachable) 객체들을 메모리에서 제거합니다.
3. **Compact**: (선택) 분산된 객체들을 모아서 메모리 단편화를 제거합니다.

---

## 4. Stop-The-World
GC를 실행하기 위해 **JVM이 애플리케이션의 실행을 멈추는 것**을 의미합니다.
- GC가 실행되는 동안 GC를 담당하는 스레드를 제외한 모든 스레드가 일시 정지됩니다.
- 빈번한 Full GC는 성능 저하의 주범이 되므로, 이 시간을 최소화하는 것이 GC 튜닝의 핵심입니다.

---

## 5. 주요 GC 알고리즘 종류
자바 버전이 올라가면서 효율적인 GC 알고리즘들이 등장했습니다.

| 종류 | 특징 |
| :--- | :--- |
| **Serial GC** | 적은 메모리와 CPU 코어 갯수에 적합. (싱글 스레드) |
| **Parallel GC** | Java 8의 기본 GC. 멀티 스레드를 사용하여 정지 시간 단축. |
| **CMS GC** | 응답 시간이 중요한 서비스에 사용 (현재는 Deprecated). |
| **G1 GC** | Java 9+ 기본 GC. 힙을 바둑판 형태(Region)로 나누어 효율적으로 관리. |
| **ZGC** | 대용량 메모리(TB 단위)에서도 정지 시간을 10ms 이하로 유지. |

---

## 6. 요약
- 자바는 **GC** 덕분에 개발자가 메모리 관리를 직접 하지 않아도 됩니다.
- 하지만 **Stop-The-World** 현상 때문에 성능 문제가 발생할 수 있으며, 이를 이해하는 것이 효율적인 자바 애플리케이션 개발의 밑바탕이 됩니다.
